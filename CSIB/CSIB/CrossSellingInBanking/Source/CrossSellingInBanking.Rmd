---
title: '<br>
 <img style="background: #FDE70F;" src="https://www.fhnw.ch/de/++theme++web16theme/assets/media/img/fachhochschule-nordwestschweiz-fhnw-logo.svg" alt="FHNW Logo" height="50rem" id="logo">
  <br><br>Challenge: Cross Selling in Banking (CED1)'
author: Gisler Luca, Heeb Christian, Studer Aaron, Bécheiraz Léonie
date: "`r format(Sys.time(), '%d.%m.%y')`"
output:
   html_document:
      toc: true
      toc_depth: 6
      toc_float: true
      collapsed: false
      code_folding: show
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE,
                      warning = FALSE)
```

```{=html}
<style type="text/css" media="screen">
h1, h2, h3 {
    color: #4D4D4D;
   }

.list-group-item.active {
    background-color: #FDE70F;
    border-color: #FDE70F;
    color: #4D4D4D;
    font-weight: bold;
}

#logo {
    padding-left: 1rem;
}

</style>
```
## Aufgabenstellung

### Allgemein

Eine tschechische Bank möchte ihre Dienstleistungen für Privatkunden
verbessern und "interessante Kundengruppen" identifizieren. Die
Geschäftsleitung hat keine präzise Vorstellung, möchte aber zusätzliches
Business generieren ohne unnötige Risiken einzugehen und Verluste
einzufahren.

Der analytische Auftrag umfasst die folgenden Aufgaben:

-   Qualität und Repräsentativität der Daten zu überprüfen
-   Die Verteilung der einzelnen Datenattribute zu erheben
-   Deren Veränderung über die Zeit zu analysieren
-   Korrelationen zwischen verschiedenen Datenattributen zu
    quantifizieren und zu visualisieren sowie Hypothesen hinsichtlich
    optimaler Produktverkauf / -nutzung zu erstellen

### Datengrundlage

Wir erhalten die Daten von einer Tschechischen Bank. Die Datengrundlage
ist auf [dieser
Webseite](https://sorry.vse.cz/~berka/challenge/PAST/index.html)
beschrieben.

## Datenbeschreibung

Die Datengrundlage enthält 8 verschiedene Tabellen (Data Frames) im .csv
Format mit Total 47 Attributen. Diese Tabellen mit den jeweiligen
Attributen werden hier genauer beschrieben.

Relation disposition (df_raw_disposition): disp_id: record identifier\
client_id: identification of a client\
account_id: identification of an account\
type: type of disposition (owner/user) only owner can issue permanent
orders and ask for a loan

#### ERD Daten IST-Zustand

![ERD Daten IST-Zustand](../Ressources/IST-Zustand.png)

## Setup

```{r}
library(tidyverse)
library(ggmosaic)
library(ggalluvial)
library(DALEXtra)
library(visdat)
library(DT)
library(patchwork)
library(ggpubr)
library(rpart.plot)
library(tidymodels)
library(lubridate)
library(cluster)
library(imputeTS)
tidymodels_prefer()
```

### Setup Account Data Frame

In diesem Schritt wird das Data Frame Account vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}

df_raw_account <- read.csv("../xselling_banking_data/account.csv", header = TRUE, sep = ";")

str(df_raw_account)

```

Es wird wie folgt die Spalte 'date' von dem Type Integer zu dem Typ Date
umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Spalte 'frequency'
ist eine kategoriale Variable mit Tschechischen Werten, daher
transformieren wir auch diese Werte auf Englisch.

```{r}

df_account <- df_raw_account %>%
  mutate(date = ymd(date)) %>%
  mutate(frequency = case_when(frequency == "POPLATEK MESICNE" ~ "Monthly",
                              frequency == "POPLATEK TYDNE" ~ "Weekly",
                              frequency == "POPLATEK PO OBRATU" ~ "After_Transaction")
  ) %>%
  arrange(account_id)

rm(df_raw_account)
```

### Setup Client Data Frame

In diesem Schritt wird das Data Frame Account vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_client <- read.csv("../xselling_banking_data/client.csv", header = TRUE, sep = ";")

str(df_raw_client)

```

Es wird wie folgt die Spalte 'birth_number' von dem Type Integer zu dem
Typ Date umgewandelt, zusätzlich nennen wir die Spalte neu
'dateofbirth'. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Es wird eine neue Spalte
'sex' hinzugefügt, mithilfe der Dokumentation der Daten kennen wir die
Kondition, welches Geschlecht der Kunde hat.

```{r}

df_client <- df_raw_client %>%
  mutate(dateofbirth = case_when(
    strtoi(substr(as.character(birth_number), 3, 3)) > 1 ~ (ymd(birth_number - 5000)),
    TRUE ~ (ymd(birth_number)),
  )) %>%
  mutate(sex = case_when(
    strtoi(substr(as.character(birth_number), 3, 3)) > 1 ~ "Female",
    TRUE  ~ "Male"
  ))

df_client <- df_client %>%
 mutate(dateofbirth = case_when(
   year(ymd(dateofbirth)) > 2000 ~ ymd(dateofbirth) - years(100),
   TRUE ~ ymd(dateofbirth)
 )) %>%
 select(client_id, district_id, dateofbirth, sex) %>%
 arrange(client_id) 

rm(df_raw_client)
```

### Setup Disposition Data Frame

In diesem Schritt wird das Data Frame Disposition vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_disposition <- read.csv("../xselling_banking_data/disp.csv", header = TRUE, sep = ";")

str(df_raw_disposition)

```

In dem Date Frame disposition müssen keine weitere Schritte erledigt
werden für das Transformieren der Daten.

```{r}

df_disposition <- df_raw_disposition %>%
 select(disp_id, client_id, account_id, type) %>%
 arrange(disp_id) 

rm(df_raw_disposition)
```

### Setup Order Data Frame

In diesem Schritt wird das Data Frame Order vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_perm_order <- read.csv("../xselling_banking_data/order.csv", header = TRUE, sep = ";")

str(df_raw_perm_order)

```

In dem Data Frame perm_order müssen wir die kategoriale Variable
'k_symbol' noch übersetzen, da der Name 'k_symbol' nicht ausschlaggeben
ist, benennen wir die Spalte zu 'payment_type' um.

```{r}

df_perm_order <- df_raw_perm_order %>%
 mutate(payment_type = case_when(k_symbol == "POJISTNE" ~ "INSURRANCE",
                              k_symbol == "SIPO" ~ "HOUSEHOLD",
                              k_symbol == "LEASING" ~ "LEASING",
                              k_symbol == "UVER" ~ "LOAN",
                              TRUE ~ "UNKNOWN")
 ) %>%
 select(order_id, account_id, bank_to, account_to, amount, payment_type) %>%
 arrange(order_id) 

rm(df_raw_perm_order)
```

### Setup Transaction Data Frame

In diesem Schritt wird das Data Frame Transaction vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_transaction <- read.csv("../xselling_banking_data/trans.csv", header = TRUE, sep = ";")

str(df_raw_transaction)

```

Es wird wie folgt die Spalte 'date' von dem Type Integer zu dem Typ Date
umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Spalte 'type' muss
von Tschechisch noch auf Englisch übersetzt werden. Dasselbe zählt auch
für die Spalte 'operation' und 'k_symbol'. Jedoch benennen wir die
Splate 'k_symbol' noch um in die neue Spalte 'characterization'.

```{r}

df_transaction <- df_raw_transaction %>%
 mutate(date = ymd(date)) %>%
 mutate(type = case_when(type == "PRIJEM" ~ "CREDIT",
                         type == "VYDAJ" ~ "WITHDRAWAL") 
 ) %>%
 mutate(operation = case_when(operation == "VYBER KARTOU" ~ "CREDIT CARD WITHDRAWAL",
                              operation == "VKLAD" ~ "CASH CREDIT",
                              operation == "PREVOD Z UCTU" ~ "COLLECTION OTHER BANK",
                              operation == "VYBER" ~ "CASH WIDTHDRAWAL",
                              operation == "PREVOD NA UCET" ~ "REMITTANCE OTHER BANK")
 ) %>%
 mutate(characterization = case_when(k_symbol == "POJISTNE" ~ "INSURRANCE PAYMENT",
                              k_symbol == "SLUZBY" ~ "STATEMENT PAYMENT",
                              k_symbol == "UROK" ~ "CREDIT INTEREST",
                              k_symbol == "SANKC. UROK" ~ "SANCTION INTEREST",
                              k_symbol == "SIPO" ~ "HOUSEHOLD",
                              k_symbol == "DUCHOD" ~ "OLD AGE PENSION",
                              k_symbol == "UVER" ~ "LOAN PAYMENT")
 ) %>%
 select(trans_id, account_id, date, type, operation, amount, balance, characterization, bank, account) %>%
 arrange(trans_id) 

rm(df_raw_transaction)
```

### Setup Loan Data Frame

In diesem Schritt wird das Data Frame Loan vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_loan <- read.csv("../xselling_banking_data/loan.csv", header = TRUE, sep = ";")

str(df_raw_loan)

```

Es wird wie folgt die Spalte 'date' von dem Type Integer zu dem Typ Date
umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Spalte 'status'
besitzt Enum-Werte. Diese Werte transformieren wir von A, B, C und D zu
den entsprechenden Bedeutungen auf English.

```{r}

df_loan <- df_raw_loan %>%
 mutate(date = ymd(date)) %>%
 mutate(status = case_when(status == "A" ~ "CONTRACT FINISHED PAYED",
                              status == "B" ~ "CONTRACT FINISHED UNPAID",
                              status == "C" ~ "CONTRACT OPEN OK",
                              status == "D" ~ "CONTRACT OPEN INDEBT",
                              TRUE ~ "")
 ) %>%
 select(loan_id, account_id, date, amount, duration, payments, status) %>%
 arrange(loan_id) 

rm(df_raw_loan)
```

### Setup Credit Card Data Frame

In diesem Schritt wird das Data Frame Credit Card vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_credit_card <- read.csv("../xselling_banking_data/card.csv", header = TRUE, sep = ";")

str(df_raw_credit_card)

```

Es wird wie folgt die Spalte 'issued' von dem Type Character zu dem Typ
Date umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Werte der Spalte
'type' werden in Upper Case umgeschrieben für eine klarere Übersicht von
kategorialen Variablen über alle Data Frames.

```{r}

df_credit_card <- df_raw_credit_card %>%
 mutate(issued  = ymd(as.integer(substr(issued, 0, 6)))) %>%
 mutate(type = case_when(type == "junior" ~ "JUNIOR",
                              type == "classic" ~ "CLASSIC",
                              type == "gold" ~ "GOLD",
                              TRUE ~ "")
 ) %>%
 select(card_id, disp_id, type, issued) %>%
 arrange(card_id) 

rm(df_raw_credit_card)
```

### Setup District Data Frame

In diesem Schritt wird das Data Frame District vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_district <- read.csv("../xselling_banking_data/district.csv", header = TRUE, sep = ";")

str(df_raw_district)

```

In dem Date Frame 'district' müssen wir alle Spalten neu benennnen, da
die einzelnen Spalten aus der Datenquelle keine Aussage über die Daten
drinhat. Daher geben wir jeder Spalte einen passenden Namen.

```{r}

df_district <- df_raw_district %>%
 mutate(district_id  = A1) %>%
 mutate(name = A2) %>%
 mutate(region = A3) %>%
 mutate(inhabitants = A4) %>%
 mutate(municipalities_under_499_inhabitants = A5) %>%
 mutate(municipalities_500_to_1999_inhabitants = A6) %>%
 mutate(municipalities_2000_to_9999_inhabitants = A7) %>%
 mutate(municipalities_over_10000_inhabitants = A7) %>%
 mutate(cities = A9) %>%
 mutate(ratio_urban_inhabitants = A10) %>%
 mutate(average_salary = A11) %>%
 mutate(unemployment_rate_95 = A12) %>%
 mutate(unemployment_rate_96 = A13) %>%
 mutate(enterpreneurs_per_1000_inhabitants = A14) %>%
 mutate(commited_crimes_95 = A15) %>%
 mutate(commited_crimes_96 = A16) %>%
 select(district_id, name, region, inhabitants, municipalities_under_499_inhabitants, municipalities_500_to_1999_inhabitants, municipalities_2000_to_9999_inhabitants, municipalities_over_10000_inhabitants, cities, ratio_urban_inhabitants, average_salary, unemployment_rate_95, unemployment_rate_96, enterpreneurs_per_1000_inhabitants, commited_crimes_95, commited_crimes_96) %>%
 arrange(district_id) 

rm(df_raw_district)
```

### ERD Ist-Zustand

In dem nachfolgend Enitity Relation Diagramm sieht man die Elemente der
transformierten Daten.

![ERD Daten IST-Zustand](../Ressources/SOLL-Zustand.png)

# A. Tabellen zusammenführen und erste Analysen

### a. Tabellen vorbereiten

Die einzelnen Tabellen werden vor dem Zusammenführen so vorbereitet,
dass pro Account nur eine Zeile vorhanden ist.

#### i. Data Frame "Permanent Order"

```{r}

summary(df_perm_order)

```

```{r}
str(df_perm_order)

```
Neuorganisation der Werte aus "payment_type" in Spalten mit der Summe der Beträge "amount" und ergänzenden Spalten mit der Information, wieviele Aufträge des gleichen Typs vorhanden sind. 
Die Spalten "order_id", "bank_to" und "account_to" werden weggelassen, da diese für die zukünftigen Analysen nicht benötigt werden.
```{r}
# summe der Beträge
df_perm_order_mod <- df_perm_order %>% 
  group_by(
    account_id,
    payment_type
  ) %>% 
  mutate(amount_sum = sum(amount)) %>% 
  group_by(
    account_id,
    payment_type,
    amount_sum
  ) %>% 
  count() %>% 
  rename(payment_type_num = n) %>% 
  pivot_wider(names_from = payment_type, values_from = c(amount_sum, payment_type_num)) %>% 
  na.replace(., 0) %>% 
  ungroup()

# str(df_perm_order_mod)

if (!grepl("order_", names(df_perm_order_mod)[2])) {
names(df_perm_order_mod) <- paste0("order_", names(df_perm_order_mod))
}

```

Überprüfung der bisher nicht beachteten Spalten "bank_to" und "account_to"
```{r}
df_perm_order %>% 
  group_by(
    bank_to, 
    account_to
  ) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  ungroup() %>% 
  head()

```

```{r}
df_perm_order %>% 
  filter(
    account_to == 79838293
  )

```
Es gibt Überweisungen, welche von verschiedenen Konten (maximal 2) auf dasselbe Ziel-Konto einzahlen. Für die Analysen, welche geplant sind, ist dieser Umstand nicht relevant. Deshalb werden diese Informationen vorerst weggelassen. Falls nötig, können sie zu einem späteren Zeitpunkt immer noch dazu genommen werden.


#### ii. Data Frame "Account"

Das Data Frame Account steht im Zentrum und beinhaltet die
Schlüsselfelder zu fast allen weiteren Tabellen. Deshalb beginnen wir
mit dem Account.
```{r}
summary(df_account)

```
Die Werte der Spalte "frequency" werden in Faktoren umgewandelt. Zudem werden zusätzliche Spalten für die Kontoeröffnungsdaten erstellt (-> Eröffnungsjahr als "opening_year", Eröffnungsmonat als "opening_month") und die Spalte "date" in "opening_date" geändert.
Anschliessend wird wieder allen Spalten das Präfix "account." erteilt.

```{r}
df_account_mod <- df_account %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(opening_year = year(date)) %>%
  mutate(opening_month = month(date)) %>%
  rename("opening_date" = "date")



if (!grepl("account_", names(df_account_mod)[2])) {
names(df_account_mod) <- paste0("account_", names(df_account_mod))
}

```

### b. Erstes Zusammenführen 

Erstes zusammenfügen der modifizierten Data Frames "df_account_mod" und "df_perm_order_mod" zum neuen Data Frame "df_mod".
```{r}

df_mod <- left_join(df_account_mod, df_perm_order_mod, by = c( "account_account_id" = "order_account_id"))

summary(df_mod)

```
Die NA's in den Spalten von "order." bedeuten, dass bei diesen Konten keine Daueraufträge hinderlegt sind. Die Zahl 0 (Null) bedeutet, dass zwar Daueraufträge hinterlegt sind, aber nicht zu diesem Themenbereich.

Nun können die nicht mehr benötigten Tabellen aus dem Global Environment entfernt werden.
```{r}
rm(df_account, df_account_mod, df_perm_order, df_perm_order_mod)

```


#### i. Data Frame "Loan"

Im weiteren Schritt wird das Data Frame "Loan" vorbereitet.
Übersicht über das Data Frame
```{r}
glimpse(df_loan)

```

Folgendes soll angepasst werden:
- die Spalte "status" wird in Faktor umgewandelt. 

- Umbenennen der Spalten:
  - "duration" zu "duration_in_month"
  - "date" zu "start_date"
  - "amount" zu "total_amount"
  - "payments" zu "redemption_amount"
  
- Zusätzliche Spalte:
  - "duration_in_years" generiert aus "duration_in_month" mit den Ganzzahlen für 
    12 = 1,
    24 = 2,
    36 = 3,
    48 = 4,
    60 = 5
  - "end_date" gerechnet aus "start_date" plus "duration_in_years"
  - "in_dept" generiert aus der Spalte "status" für
    "CONTRACT FINISHED PAYED" und "CONTRACT OPEN OK" = "NO"
    "CONTRACT FINISHED UNPAID" und "CONTRACT OPEN INDEBT" = "YES"
  
```{r}
df_loan_mod <- df_loan %>%
  # mutate(across(c(status), as.factor)) %>%
  rename(
    "duration_in_month" = "duration",
    "start_date" = "date",
    "total_amount" = "amount",
    "redemption_amount" = "payments"
    ) %>%
  mutate(
    duration_in_years = case_when(duration_in_month == 12 ~ 1,
                                  duration_in_month == 24 ~ 2,
                                  duration_in_month == 36 ~ 3,
                                  duration_in_month == 48 ~ 4,
                                  duration_in_month == 60 ~ 5
  )) %>%
  mutate(end_date = start_date + years(duration_in_years)) %>%
  mutate(in_dept = if_else(c(status == "CONTRACT FINISHED PAYED" |
                             status == "CONTRACT OPEN OK"), "NO", "YES")) %>%
  mutate(across(where(is.character), as.factor)) %>%
  relocate(end_date, .after = start_date) %>%
  relocate(starts_with("duration"), .after = end_date)

  levels(df_loan_mod$status)

```

Überprüfung, ob ein Account mehrere Darlehen hat.
```{r}
df_loan_mod %>%
  group_by(account_id) %>%
  count() %>%
  arrange(desc(n)) %>%
  ungroup() %>% 
  head()

```

Da es pro Account nur jeweils 1 Darlehensvertrag gibt, braucht es für diese Tabelle keine weiteren Anpassungen.
Es wird nur noch das Präfix "loan." hizugefügt, bevor ein Anfügen an die Gesamttabelle erfolgt.
```{r}
if (!grepl("loan_", names(df_loan_mod)[2])) {
names(df_loan_mod) <- paste0("loan_", names(df_loan_mod))
}

```
 
#### Zweites Zusammenführen

Loan wird zum Data Frame "df_mod" hinzugefügt.
```{r}
df_mod <- left_join(df_mod, df_loan_mod, by = c("account_account_id" = "loan_account_id"))
 
summary(df_mod)
 
```
#### Bedeutung der NA's

Die NA's in den Spalten von "loan_" bedeuten, dass bei diesen Konten keine Darlehen hinderlegt sind, analog den Informationen aus den Spalten "order_"
 
Entfernen der nicht mehr benötigten Tabellen aus dem Global Environment.
```{r}
rm(df_loan, df_loan_mod)

```

 
#### ii. Data Frame "disposition"
 
Übersicht über das Data Frame
```{r}
glimpse(df_disposition)

```
#### Anpassungen

- Werte in der Spalte type umbenennen (Disponent zu User)
- neue Spalte mit Anzahl Benutzer pro Konto (account_user_num)
- Werte der Spalte type in neue Spalten aufteilen mit Bezeichnung und Werten aus client_id und disp_id
```{r}
df_disposition_mod <- df_disposition %>% 
   mutate(type = ifelse(c(type == "OWNER"), "OWNER", "USER")) %>% 
   pivot_wider(names_from = type, values_from = c(client_id, disp_id))

#Spalte mit Anzahl User pro Account
df_disposition_num_user <- df_disposition %>% 
  group_by(
    account_id
  ) %>% 
  count() %>% 
  rename(account_num_of_user = n) %>% 
  ungroup()

#Anfügen der neuen Spalte "account.num_of_user" an das df_disposition_mod
df_disposition_mod <- left_join(df_disposition_mod, df_disposition_num_user, by = "account_id")

summary(df_disposition_mod)
 
```
#### Bedeutung der NA's

Die NA's in den Spalten mit den User-Daten kommen daher, dass bei diesen Accounts nur 1 Benutzer (Owner) eingetragen ist.
 
Wiederum wird den Spalten ein Präfix hinzugefügt (disp.)
```{r}
if (!grepl("disp_", names(df_disposition_mod )[2])) {
names(df_disposition_mod) <- paste0("disp_", names(df_disposition_mod))
}

```
 
### c. Drittes Zusammenführen
 
```{r}
df_mod <- left_join(df_mod, df_disposition_mod, by = c("account_account_id" = "disp_account_id"))

glimpse(df_mod)

```
Entfernen der nicht mehr benötigten Tabellen
```{r}
rm(df_disposition, df_disposition_mod, df_disposition_num_user)

```

#### i. Data Frame "credit card"
```{r}
glimpse(df_credit_card)

```
Hier braucht es nur eine Umformung der Spalte "type" in Faktor und das Anfügen des Präfixes (card.)
```{r}
df_credit_card_mod <- df_credit_card %>% 
   mutate(across(where(is.character), as.factor))

if (!grepl("card_", names(df_credit_card_mod)[2])) {
names(df_credit_card_mod) <- paste0("card_", names(df_credit_card_mod))
}
    
glimpse(df_credit_card_mod)

```
 
### d. Viertes Zusammenführen
```{r}
df_mod <- left_join(df_mod, df_credit_card_mod, by = c("disp_disp_id_OWNER" = "card_disp_id"))
 
glimpse(df_mod)
 
```
 
Überprüfen, ob alle Kreditkarten übernommen wurden
```{r}
summary(df_mod$card_type)

```
Gesamthaft wurden 892 Kreditkarten-Informationen übernommen.
 
Entfernen der nicht mehr benötigten Tabellen.
```{r}
rm(df_credit_card, df_credit_card_mod)

```
 
#### i. Data Frame "client"

```{r}
glimpse(df_client)

```
Bei dieser Tabelle wird das Geschlecht in Faktoren umgewandelt und eine zusätzliche Spalte für das Alter bei der Kontoeröffnung erstellt. Diese zusätzliche Spalte kann erst nach dem Zusammenfügen mit den Account-Daten generiert werden.
Danach können die Informationen in df_mod eingefügt werden. Dazu werden zwei verschiedene Tabellen erstellt, eine für Owner und eine für den User.
```{r}
df_client_mod <- df_client %>% 
 mutate(across(where(is.character), as.factor))
 
df_client_user <- df_client_mod
df_client_owner <- df_client_mod

if (!grepl("user_", names(df_client_user)[2])) {
names(df_client_user) <- paste0("user_", names(df_client_user))
}
 
if (!grepl("owner_", names(df_client_owner)[2])) {
names(df_client_owner) <- paste0("owner_", names(df_client_owner))
}
 
```
 
### e. Fünftes Zusammenführen

```{r}
df_mod <- left_join(df_mod, df_client_owner, by = c("disp_client_id_OWNER" = "owner_client_id"))
df_mod <- left_join(df_mod, df_client_user, by = c("disp_client_id_USER" = "user_client_id"))

```

Entfernen der nicht mehr benötigten Tabellen "client"
```{r}
rm(df_client, df_client_mod, df_client_owner, df_client_user)

```
Spalten werden neu angeordnet und wo sinnvoll, umbenannt:

Umbenennen:
- disp_client_id_OWNER wird zu owner_client_id,
- disp_client_id_USER wird zu user_client_id,
- disp_disp_id_OWNER wird zu owner_disp_id,
- disp_disp_id_USER wird zu user_disp_id,
- card_card_id wird zu card_id,
- loan_loan_id wird zu loan_id,
- account_account_id wird zu account_id,
-   order_amount_sum_HOUSEHOLD wird zu owner_client_id,
-   order_amount_sum_INSURRANCE wird zu order_amount_insurrance,
-   order_amount_sum_LOAN wird zu order_amount_loan,
-   order_amount_sum_UNKNOWN wird zu order_amount_unknown,
-   order_amount_sum_LEASING wird zu order_amount_leasing,
-   order_payment_type_num_HOUSEHOLD wird zu order_num_household,
-   order_payment_type_num_INSURRANCE wird zu order_num_insurrance,
-   order_payment_type_num_LOAN wird zu order_num_loan,
-   order_payment_type_num_UNKNOWN wird zu order_num_unknown,
-   order_payment_type_num_LEASING wird zu order_num_leasing

```{r}
# Spalten umbenennen und neu anordnen
df_mod  <- df_mod %>%
 rename(
   owner_client_id = disp_client_id_OWNER,
   user_client_id = disp_client_id_USER,
   owner_disp_id = disp_disp_id_OWNER,
   user_disp_id = disp_disp_id_USER,
   card_id = card_card_id,
   loan_id = loan_loan_id,
   account_id = account_account_id,
   account_num_of_user = disp_account_num_of_user,
   order_total_amount_household = order_amount_sum_HOUSEHOLD,
   order_total_amount_insurrance = order_amount_sum_INSURRANCE,
   order_total_amount_loan = order_amount_sum_LOAN,
   order_total_amount_unknown = order_amount_sum_UNKNOWN,
   order_total_amount_leasing = order_amount_sum_LEASING,
   order_num_household = order_payment_type_num_HOUSEHOLD,
   order_num_insurrance = order_payment_type_num_INSURRANCE,
   order_num_loan = order_payment_type_num_LOAN,
   order_num_unknown = order_payment_type_num_UNKNOWN,
   order_num_leasing = order_payment_type_num_LEASING
 ) 

#zusätzliche Spalte erstellen für das Alter der Owner bei der Kontoeröffnung.
df_mod <- df_mod %>% 
  mutate(owner_age_at_account_opening = round(as.numeric(account_opening_date - owner_dateofbirth)/365)) %>% 
  mutate(user_age_at_account_opening = round(as.numeric(account_opening_date - user_dateofbirth)/365))

```

#### i. Data Frame "District"

Übersicht über das Data Frame.
```{r}
glimpse(df_district)

```
unemployment_rate_95 in dbl
commited_crimes_95 in int
anschliessend alle chr in factor

```{r}
df_district <- df_district %>% 
  mutate(across(c(unemployment_rate_95), as.double),
         across(c(commited_crimes_95), as.integer),
         across(where(is.character), as.factor))

glimpse(df_district)

```
Erstellen des Data Frames für den Import in das "df_mod"
```{r}

df_district_mod <- df_district

if (!grepl("district_", names(df_district_mod )[2])) {
names(df_district_mod) <- paste0("district_", names(df_district_mod))
}

#Auswahl der Spalten für den Übertrag
df_district_select <- df_district_mod %>% 
  select(
    district_district_id,
    district_name,
    district_region,
    district_average_salary,
    district_inhabitants
  )

#Erstellen von zwei Data Frames für Account und Owner
df_district_account <- df_district_select
if (!grepl("account_", names(df_district_account )[2])) {
names(df_district_account) <- paste0("account_", names(df_district_account))
}

df_district_owner <- df_district_select
if (!grepl("owner_", names(df_district_owner )[2])) {
names(df_district_owner) <- paste0("owner_", names(df_district_owner))
}

rm(df_district)

```

Die vorbereiteten Observationen können nun dem df_mod hinzugefügt werden.
```{r}
df_mod <- left_join(df_mod, df_district_account, by = c("account_district_id" = "account_district_district_id"))

df_mod <- left_join(df_mod, df_district_owner, by = c("account_district_id" = "owner_district_district_id"))

```

Entfernen der nicht mehr benötigten Tabellen.
```{r}
rm(df_district_account, df_district_owner, df_district_select)
#das df_district wird vorerst noch belassen, ev. wird es in einem späteren Schritt nochmals verwendet

```

Für das konsolidierte Data Frame werden die Spalten neu angeordnet.
```{r}
#dieser Code verwenden, um das df_cons zu erstellen
df_mod <- df_mod %>%
  relocate(starts_with("account_")) %>% 
  relocate(starts_with("owner_"), .after = last_col()) %>%
  relocate(starts_with("user_"), .after = last_col()) %>%
  relocate(contains("id"), .after = last_col()) %>% 
  relocate(account_id)

glimpse(df_mod)

```
# B. Erste Analysen

#### a. Sonderstellung: Bedeutung des Account Owner

Wie wir bei der Datenbeschreibung bereits gelesen haben, enthält
disposition_type die Information über die Rechte der Konten. Deshalb
wurde  der Eintrag beim Aufbereiten des df_disposition von "disponent" in "user" geändert. Denn nur der "owner" hat die nötigen Berechtigungen, um Daueraufträge zu erteilen und
Darlehen zu beantragen. So wird die Auswertung übersichtlicher.

#### b. Auf Duplikate überprüfen
```{r}
n_distinct(df_mod)

```
Es sind keine Duplikate vorhanden.

# C. Data Frame "transaction"

Das Data Frame Transaction wird vorerst separat aufbereitet und ersten Analysen unterzogen. Aus den folgenden Analysen werden neue Spalten generiert, welche dann in einem weiteren Schritt in den konsolidierten Datensatz df_cons übernommen werden können. 
Auch wird während den Analysen entschieden, ob zusätzlich zum konsolidierten Datensatz noch ein Datensatz mit Transaktionsdaten bestehen bleibt, oder ob alles in df_cons zusammengeführt wird.

Übersicht über die Tabelle df_transaction.
```{r}
glimpse(df_transaction)

```
#### Dateitypen anpassen

Characters in Faktoren ändern.
```{r}
df_transaction_mod <- df_transaction %>% 
  mutate(across(where(is.character), as.factor))

summary(df_transaction_mod)
rm(df_transaction)

```
#### Spalten umbenennen

- bank wird zu bank_name
- account wird zu account_nr
- type wird zu cashflow

```{r}
df_transaction_mod <- df_transaction_mod %>% 
  rename(
    bank_name = bank,
    account_nr = account,
    cashflow = type
  )

```

#### a. Untersuchen der NA's

Als erstes beginnen wir mit der neu benannten Spalte cashflow
```{r}
df_transaction_mod %>% 
  filter(is.na(cashflow)) %>% 
  summary()

```

Die NA's in "cashflow" und "characterization" sind Geldausgänge und können deshalb als Werte in die beiden Spalten imputiert werden. Bei der Spalte "bank_name" fällt auf, dass die Werte leer sind. Deshalb wird dort mit NA's ergänzt.
Es könnte sich bei diesen Geldbezügen um Bezüge an den Automaten handeln. Dies kann aber erst überprüft werden, wenn diese Informationen mit den Beobachtungen aus der Tabelle mit den Kreditkarten-Informationen abgeglichen werden kann.
Diese Analyse kann zu einem späteren Zeitpunkt vorgenommen werden.

#### b. Imputieren
##### Code fertig schreiben
```{r}
#Liste für die gezielte Imputation in "characterization" mit "CASH WIDTHDRAWAL"
list_na_characterization_for_cashwidthrawal <- df_transaction_mod %>% 
  filter(is.na(cashflow)) %>% 
  select(trans_id)

list_transid_for_imputation <- as.list(list_na_characterization_for_cashwidthrawal)

# der Code muss hier noch geschrieben werden. Dazu %in% verwenden.

# das Imputieren der Werte in characterization geschieht mit %in% dazu muss der Code noch gefunden werden. Ist für den Moment nicht so dringend. Für dieses Imputieren wurde die Liste list_na_characterization_for_cashwidthrawal erstellt -> mit %in%

n_row_na <- nrow(list_na_characterization_for_cashwidthrawal)
  
```

#### Cashflow mit "IN" und "OUT" mutieren

Nebst dem Mutieren werden die NA's mit "OUT" imputiert. Dies geht aus der vorgängigen Analyse hervor.
```{r}
df_transaction_mod <- df_transaction_mod %>% 
  mutate(cashflow = case_when(cashflow == "WITHDRAWAL" ~ "OUT",
                              cashflow == "CREDIT" ~ "IN",
                              TRUE ~ "OUT")) %>%
  mutate(across(where(is.character), as.factor))

head(df_transaction_mod)

```

```{r}
rm(list_na_characterization_for_cashwidthrawal, list_transid_for_imputation)
```


### c. Bilanz Ende Jahr

#### Erstellen zusätzlicher Spalten "year" und "month"

Im Data Frame "df_transaction_mod" werden zwei zusätzliche Spalten für das Jahr der Transaktion sowie für den Monat erstellt.
```{r}
df_transaction_mod <- df_transaction_mod %>% 
  mutate(
    year = year(date),
    month = month(date)
  )

head(df_transaction_mod)

```
#### durchschnittliche Bilanz
```{r}
years_avg <- df_transaction_mod %>% 
  group_by(
    account_id,
    cashflow,
    year
  ) %>% 
  summarise(amount_mean = mean(amount)) %>% 
  pivot_wider(names_from = cashflow, values_from = amount_mean) %>% 
  mutate(balance_sheet = IN - OUT) %>% 
  ungroup()

balance_sheet <- years_avg %>% 
    select(
      account_id,
      year,
      balance_sheet
    ) %>% 
    arrange(year) %>% 
    pivot_wider(names_from = year, values_from = balance_sheet) %>% 
    arrange(account_id)
  
if (!grepl("balance_sheet_end_of.", names(balance_sheet)[2])) {
names(balance_sheet) <- paste0("balance_sheet_end_of.", names(balance_sheet))
}

head(years_avg)
head(balance_sheet)

```
Für die Analysen werden noch die jeweiligen mittleren Werte der Kontostände benötigt. Dazu wird ein zusätzliches Data Frame mit den Mittelwerten erstellt.
```{r}
transaction_cashflow_per_month_and_year_mean <- df_transaction_mod %>%
  group_by(
    year,
    month,
    account_id,
    cashflow,
    ) %>%
  arrange(year, month) %>%
  summarise(amount_mean = mean(amount)) %>%
  pivot_wider(names_from = cashflow, values_from = amount_mean) %>% 
  mutate(IN = replace_na(IN, 0)) %>% 
  mutate(OUT = replace_na(OUT, 0)) %>% 
  mutate(balance = IN - OUT) 

balance_per_month_mean <- transaction_cashflow_per_month_and_year_mean %>% 
  select(
    account_id,
    year,
    month,
    balance
  ) %>% 
  pivot_wider(names_from = c(year,month), values_from = balance)

head(transaction_cashflow_per_month_and_year_mean)
head(balance_per_month_mean)

```

#### *wichtige Erkenntnis*
Eine Überprüfung der Werte hat ergeben, dass dies so nicht gerechnet werden Kann. Es entstehen dabei Rechnungsfehler, da zum Beispiel bei einem Eingang mit meheren Werten der Durchschnitt berechnet wird und wenn dann ein Ausgang mit nur einem Wert vorhanden ist, dieser abgezogen wird, stimmt das Verhältnis der Beträge nicht mehr. Daher wird nur die Berechnung mit den totalen verwendet und damit weiter gearbeitet!

#### Balance Data Frames entfernen
```{r}
rm(balance_per_month_mean, balance_per_month_total_lag, balance_sheet_per_years_total, transaction_cashflow_per_month_and_year_mean, transaction_cashflow_per_month_and_year_total)

```


#### C.1. Kontostand Ende Monat

Als erstes werden die Kontostände per Ende jeden Monats berechnet. Dazu müssen die entstehenden NA's mit der Zahl Null ersetzt werden, da ja bei diesen Kontoständen sowie Geldein-/ausgängen 0 CZK vorhanden sind.
```{r}
transaction_cashflow_per_month_and_year_total <- df_transaction_mod %>%
  group_by(
    year,
    month,
    account_id,
    cashflow,
    ) %>%
  arrange(year, month) %>%
  summarise(amount_total = sum(amount)) %>%
  pivot_wider(names_from = cashflow, values_from = amount_total) %>%
  mutate(IN = replace_na(IN, 0)) %>%
  mutate(OUT = replace_na(OUT, 0)) %>%
  mutate(balance_sheet = IN - OUT) %>% 
  ungroup()

head(transaction_cashflow_per_month_and_year_total)

```
Versuch, eine Funktion für die Berechnung der monatlichen Kontständen zu schreiben.
```{r}
# balancefunc <- function()
#   
#   if (!grepl("incomes_avg_per.", names(incomes_avg_per_year)[2])) {
# names(incomes_avg_per_year) <- paste0("incomes_avg_per.", names(incomes_avg_per_year))
#   }

```
##### lead und lag

weiterer Versuch mit lead() und lag() den Kontostand Ende Monat auszurechnen:
```{r}
balance_per_month_total_lead <- transaction_cashflow_per_month_and_year_total %>% 
  arrange(account_id) %>% 
  mutate(account_id_lead = dplyr::lead(account_id)) %>% 
  mutate(account_id_lead = replace_na(account_id_lead, 0)) %>% 
  mutate(balance_lead = dplyr::lead(balance_sheet)) %>% 
  mutate(balance_lead = replace_na(balance_lead, 0)) %>%
  mutate(balance_per_month = ifelse(c(account_id == account_id_lead), balance_sheet + balance_lead, balance_sheet)) %>% 
  relocate(account_id_lead)
  

balance_per_month_total_lag <- transaction_cashflow_per_month_and_year_total %>% 
  arrange(account_id) %>% 
  mutate(account_id_lag = dplyr::lag(account_id)) %>% 
  mutate(account_id_lag = replace_na(account_id_lag, 0)) %>% 
  relocate(account_id_lag) %>% 
  mutate(row_num = 1: nrow(.)) %>%
  mutate(row_num_lag = dplyr::lag(row_num)) %>% 
  mutate(balance_per_month = ifelse(c(account_id != account_id_lag), balance_sheet, 0)) %>%   mutate(balance_per_month = ifelse(c(account_id == account_id_lag), balance_per_month[row_num_lag] + balance_sheet, balance_per_month))

# (balance_per_month[row_num - 1] + balance_sheet))) 

#  mutate(balance_per_month = ifelse(c(is.na(balance_per_month)), (balance_per_month[row_num - 1] + balance_sheet), balance_per_month))
  
  # mutate(balance_per_month = ifelse(c(is.na(balance_per_month)), balance_per_month[row_num - 1] + balance_sheet, balance_per_month))
                                    
# balance_per_month[which(balance_per_month %in% c(balance_per_month))] , balance_per_month)) 

# balance_per_month_total_lag %>% 
#   group_by(account_id) %>% 
#   slice_head(n = 1) %>% 
#   summary()

#   pivot_wider(names_from = c(year,month), values_from = balance)

# summary(transaction_cashflow_per_month_and_year_total)

head(balance_per_month_total_lead)
head(balance_per_month_total_lag)

```
#### C.2. Suche nach einer anderen Möglichkeit für die monatlichen Kontoauszügen

Im ursprünglichen Datensatz "df_transaction_mod" sind die Kontostände nach jeder Transaktion vorhanden. Es sollte möglich sein, anhand des letzten Datums herauszufinden, welches die letzte Transaktion war und somit welches der Kontostand Ende Monat ist. 
Dazu wird ein Zufallsgenerator erstellt, um verschiedene Konten genauer zu untersuchen.
```{r}
#Zufallsnummer
n = runif(1, min = 0, max = nrow(df_transaction_mod))

df_transaction_mod %>% 
  arrange(date) %>%
  filter(
    account_id == account_id[n],
    year == 1995,
    month == 3
  ) 

rm(n)

```
Es fällt auf, dass die letzte Transaktion immer der Betrag 14.6 ist. Es ist immer ein OUT. Diese Hypothese wird nun nochmals überprüft.

```{r}
df_transaction_mod %>% 
  filter(
    amount == 14.6
  )
  
```
##### Kontogebühren
Es handelt sich hier vermutlich um Kontogebühren, welche als letzte Transaktion getätigt werden. Nun wird noch nach dem Wert "STATEMENT PAYMENT" gefiltert.
```{r}
df_transaction_mod %>% 
  filter(
    characterization == "STATEMENT PAYMENT"
  ) %>% 
  arrange(desc(amount))

```
Die Beträge sind nicht immer gleich hoch. Dies soll genauer untersucht werden. Damit die verschiedenen vorkommenden Beträge aufgelistet werden können, wird eine zusätzliche Spalte generiert, in der die Werte zu Faktoren umgewandelt werden. Anschliessend können die Levels angezeigt werden. Die Hypothese ist, dass die Höhe er Beträge Aussagen macht, ob es sich dabei um Privat- oder Geschäftskunden handelt.
```{r}
df_statement_payment_levels <- df_transaction_mod %>% 
  filter(
    characterization == "STATEMENT PAYMENT"
  ) %>% 
  mutate(amount_levels = as.factor(amount))

levels(df_statement_payment_levels$amount_levels)

```
Es gibt gesamthahft 3 verschieden hohe Gebühren für die Konten: 14.60, 30, 100.

Entfernen des df_statement_payment_levels
```{r}
rm(df_statement_payment_levels)

```
Bei einer späteren Analyse kann versucht werden, die Gebührenhöhe zu erklären.
Dabei können folgende Fragen beantwortet werden:
- Handelt es sich bei den Konten mit der Gebühr 100 um Geschäftskonten? 
- Sind diese Konten in einer bestimmten Filiale oder einem bestimmten District? 
- Wurden die Kontogebühren über die Jahre erhöht?

Es wird nun aber weiter am Datensatz für die monatlichen Gebühren gearbeitet.
Dafür muss überprüft werden, ob immer Ende Monat eine Kontogebühr abgebucht wurde.

#### 2.a. Erstellen des Datensatzes für die monatlichen Kontostände
statement_payment
```{r}
statement_payment <- df_transaction_mod %>% 
  filter(
    characterization == "STATEMENT PAYMENT"
  ) %>% 
  mutate(
    statement_payment = date
  ) %>% 
  select(
    trans_id,
    statement_payment
  )

head(statement_payment)

```
balance_per_month
```{r}
balance_per_month <- df_transaction_mod %>% 
  select(
    trans_id
  ) 

balance_per_month <- left_join(balance_per_month, statement_payment, by = "trans_id")

rm(statement_payment)
head(balance_per_month)

```

Untersuchen eines zufälligen Accounts
```{r}
#Zufallsnummer
n = runif(1, min = 0, max = nrow(df_transaction_mod))

df_transaction_mod %>% 
  filter(
    account_id == account_id[n]
  ) %>% 
  arrange(date)

rm(n)

```
Es gibt Monate, in denen keine Kontogebühren verrechnet wurden. Die Hypothese dazu ist, dass ein Neukunde die ersten drei Monate keine Gebühren zahlt. Dies soll überprüft werden.

##### letzter Tag im Monat
last_day_in_month
```{r}
last_day_in_month <- df_transaction_mod %>% 
  group_by(
    account_id,
    year,
    month
  ) %>% 
  mutate(last_day = max(date)) %>% 
  ungroup()

head(last_day_in_month)

```
```{r}
last_day_in_month <- last_day_in_month %>% 
  filter(
    date == last_day
  ) %>% 
  arrange(
    account_id,
    date
  )
last_day_in_month

```
Bei der Kontoeröffnung ist der Amount gleich hoch wie die Balance. Diese Information kann in "characterization" imputiert werden.

##### Kontoeröffnung
account_opening
```{r}

account_opening <- df_transaction_mod %>% 
  filter(
    amount == balance,
    cashflow == "IN"
  ) %>% 
  mutate(
    account_opening = date
  )

head(account_opening)

```

Die Erkenntnisse aus den Kontoeröffnungen werden nun dem Data Frame "balance_per_month" angefügt.
```{r}
foo <- account_opening %>% 
  select(
    trans_id,
    account_opening
  )

balance_per_month <- left_join(balance_per_month, foo, by = "trans_id")

rm(foo)
head(balance_per_month)

```

```{r}
foo <- last_day_in_month %>% 
  select(
    trans_id,
    last_day
  )

balance_per_month <- left_join(balance_per_month, foo, by = "trans_id")
rm(foo)
head(balance_per_month)

```

```{r}
balance_per_month <- left_join(balance_per_month, df_transaction_mod, by = "trans_id")
head(balance_per_month)

```
##### auf Duplikate überprüfen
```{r}
num <- balance_per_month %>% 
  filter(
    !is.na(last_day),
    is.na(statement_payment),
    is.na(account_opening)
    ) %>% 
  group_by(
    account_id,
    year,
    month
  ) %>% 
  ungroup()

nrow(num)
n_distinct <- num %>% select(account_id, date) %>% n_distinct()
n_distinct

```
Es gibt einige Daten, an denen mehrere Zahlungen am selben Tag erfolgten.

#### 2.b. Einzelzahlungen am letzten Tag des Monats

Alle Kontostände pro Monatsende mit nur einer Transaktion können entsprechend ergänzt werden.

balance_per_month
```{r}
foo <- balance_per_month %>%
  filter(
    !is.na(last_day),
    is.na(statement_payment),
    is.na(account_opening)
    ) %>%
  group_by(
    account_id,
    year,
    month
  ) %>%
  count() %>%
  ungroup() %>%
  filter(
    n == 1
  ) %>%
  rename(is_unique = n)
  
balance_per_month <- left_join(balance_per_month, foo, by = c("account_id", "year", "month"))

rm(foo)
head(balance_per_month)

```
##### mehrere Transaktionen am selben Tag

Nun werden alle Zeilen gekennzeichnet, welche mehrere Transaktionen am Ende des Monats haben und noch nicht zugeordnet werden konnten.
```{r}
foo <- balance_per_month %>%
  filter(
    !is.na(last_day),
    is.na(statement_payment),
    is.na(account_opening)
    ) %>%
  group_by(
    account_id,
    year,
    month
  ) %>%
  count() %>%
  ungroup() %>%
  filter(
    n > 1
  ) %>%
  rename(is_not_unique = n)
  
balance_per_month <- left_join(balance_per_month, foo, by = c("account_id", "year", "month"))

rm(foo)
head(balance_per_month)

```

```{r}
balance_per_month %>% 
  filter(
    !is.na(is_not_unique),
    !is.na(last_day),
    is.na(statement_payment),
    is.na(account_opening)
  ) %>% 
  arrange(
    account_id,
    date
  ) %>% 
  arrange(desc(is_not_unique))

```
Alle diese Versuche führen nicht zum Ziel.

#### Entfernen der nicht mehr benötigten Tabellen
```{r}
rm(account_opening, balance_per_month, balance_per_month_total_lag, balance_per_month_total_lead, balance_sheet, last_day_in_month, num, years_avg, n_distinct, n_row_na, transaction_cashflow_per_month_and_year_total)

```


#### Weiterer Versuch, den Kontoendstand pro Monat zu eruieren. (Code von Aaron)

Dazu wird der jeweilige Kontoendstand des Vormonats genommen und von diesem alle Geldein- sowie Ausgänge dazu gerechnet beziehungsweise abgezogen. 
```{r}

transaction_cashflow_per_month_and_year <- df_transaction_mod %>%
  group_by(
    account_id,
    cashflow,
    year,
    month
  ) %>%
  summarise(amount_mean = mean(amount)) %>%
  # arrange(year, month) %>%
  pivot_wider(names_from = c(cashflow,year,month), values_from = amount_mean)

str(transaction_cashflow_per_month_and_year)

transaction_mod_balance_per_month <- transaction_cashflow_per_month_and_year %>%
  mutate(account_id = account_id) %>%
  mutate(balance_1993_1 = IN_1993_1 - OUT_1993_1) %>%
  mutate(balance_1993_2 = balance_1993_1 + (IN_1993_2 - OUT_1993_2)) %>%
  mutate(balance_1993_3 = balance_1993_2 + (IN_1993_3 - OUT_1993_3)) %>%
  mutate(balance_1993_4 = balance_1993_3 + (IN_1993_4 - OUT_1993_4)) %>%
  mutate(balance_1993_5 = balance_1993_4 + (IN_1993_5 - OUT_1993_5)) %>%
  mutate(balance_1993_6 = balance_1993_5 + (IN_1993_6 - OUT_1993_6)) %>%
  mutate(balance_1993_7 = balance_1993_6 + (IN_1993_7 - OUT_1993_7)) %>%
  mutate(balance_1993_8 = balance_1993_7 + (IN_1993_8 - OUT_1993_8)) %>%
  mutate(balance_1993_9 = balance_1993_8 + (IN_1993_9 - OUT_1993_9)) %>%
  mutate(balance_1993_10 = balance_1993_9 + (IN_1993_10 - OUT_1993_10)) %>%
  mutate(balance_1993_11 = balance_1993_10 + (IN_1993_11 - OUT_1993_11)) %>%
  mutate(balance_1993_12 = balance_1993_11 + (IN_1993_12 - OUT_1993_12)) %>%
  mutate(balance_1994_1 = balance_1993_12 + (IN_1994_1 - OUT_1994_1)) %>%
  mutate(balance_1994_2 = balance_1994_1 + (IN_1994_2 - OUT_1994_2)) %>%
  mutate(balance_1994_3 = balance_1994_2 + (IN_1994_3 - OUT_1994_3)) %>%
  mutate(balance_1994_4 = balance_1994_3 + (IN_1994_4 - OUT_1994_4)) %>%
  mutate(balance_1994_5 = balance_1994_4 + (IN_1994_5 - OUT_1994_5)) %>%
  mutate(balance_1994_6 = balance_1994_5 + (IN_1994_6 - OUT_1994_6)) %>%
  mutate(balance_1994_7 = balance_1994_6 + (IN_1994_7 - OUT_1994_7)) %>%
  mutate(balance_1994_8 = balance_1994_7 + (IN_1994_8 - OUT_1994_8)) %>%
  mutate(balance_1994_9 = balance_1994_8 + (IN_1994_9 - OUT_1994_9)) %>%
  mutate(balance_1994_10 = balance_1994_9 + (IN_1994_10 - OUT_1994_10)) %>%
  mutate(balance_1994_11 = balance_1994_10 + (IN_1994_11 - OUT_1994_11)) %>%
  mutate(balance_1994_12 = balance_1994_11 + (IN_1994_12 - OUT_1994_12)) %>%
  mutate(balance_1995_1 = balance_1994_12 + (IN_1995_1 - OUT_1995_1)) %>%
  mutate(balance_1995_2 = balance_1995_1 + (IN_1995_2 - OUT_1995_2)) %>%
  mutate(balance_1995_3 = balance_1995_2 + (IN_1995_3 - OUT_1995_3)) %>%
  mutate(balance_1995_4 = balance_1995_3 + (IN_1995_4 - OUT_1995_4)) %>%
  mutate(balance_1995_5 = balance_1995_4 + (IN_1995_5 - OUT_1995_5)) %>%
  mutate(balance_1995_6 = balance_1995_5 + (IN_1995_6 - OUT_1995_6)) %>%
  mutate(balance_1995_7 = balance_1995_6 + (IN_1995_7 - OUT_1995_7)) %>%
  mutate(balance_1995_8 = balance_1995_7 + (IN_1995_8 - OUT_1995_8)) %>%
  mutate(balance_1995_9 = balance_1995_8 + (IN_1995_9 - OUT_1995_9)) %>%
  mutate(balance_1995_10 = balance_1995_9 + (IN_1995_10 - OUT_1995_10)) %>%
  mutate(balance_1995_11 = balance_1995_10 + (IN_1995_11 - OUT_1995_11)) %>%
  mutate(balance_1995_12 = balance_1995_11 + (IN_1995_12 - OUT_1995_12)) %>%
  mutate(balance_1996_1 = balance_1995_12 + (IN_1996_1 - OUT_1996_1)) %>%
  mutate(balance_1996_2 = balance_1996_1 + (IN_1996_2 - OUT_1996_2)) %>%
  mutate(balance_1996_3 = balance_1996_2 + (IN_1996_3 - OUT_1996_3)) %>%
  mutate(balance_1996_4 = balance_1996_3 + (IN_1996_4 - OUT_1996_4)) %>%
  mutate(balance_1996_5 = balance_1996_4 + (IN_1996_5 - OUT_1996_5)) %>%
  mutate(balance_1996_6 = balance_1996_5 + (IN_1996_6 - OUT_1996_6)) %>%
  mutate(balance_1996_7 = balance_1996_6 + (IN_1996_7 - OUT_1996_7)) %>%
  mutate(balance_1996_8 = balance_1996_7 + (IN_1996_8 - OUT_1996_8)) %>%
  mutate(balance_1996_9 = balance_1996_8 + (IN_1996_9 - OUT_1996_9)) %>%
  mutate(balance_1996_10 = balance_1996_9 + (IN_1996_10 - OUT_1996_10)) %>%
  mutate(balance_1996_11 = balance_1996_10 + (IN_1996_11 - OUT_1996_11)) %>%
  mutate(balance_1996_12 = balance_1996_11 + (IN_1996_12 - OUT_1996_12)) %>%
  mutate(balance_1997_1 = balance_1996_12 + (IN_1997_1 - OUT_1997_1)) %>%
  mutate(balance_1997_2 = balance_1997_1 + (IN_1997_2 - OUT_1997_2)) %>%
  mutate(balance_1997_3 = balance_1997_2 + (IN_1997_3 - OUT_1997_3)) %>%
  mutate(balance_1997_4 = balance_1997_3 + (IN_1997_4 - OUT_1997_4)) %>%
  mutate(balance_1997_5 = balance_1997_4 + (IN_1997_5 - OUT_1997_5)) %>%
  mutate(balance_1997_6 = balance_1997_5 + (IN_1997_6 - OUT_1997_6)) %>%
  mutate(balance_1997_7 = balance_1997_6 + (IN_1997_7 - OUT_1997_7)) %>%
  mutate(balance_1997_8 = balance_1997_7 + (IN_1997_8 - OUT_1997_8)) %>%
  mutate(balance_1997_9 = balance_1997_8 + (IN_1997_9 - OUT_1997_9)) %>%
  mutate(balance_1997_10 = balance_1997_9 + (IN_1997_10 - OUT_1997_10)) %>%
  mutate(balance_1997_11 = balance_1997_10 + (IN_1997_11 - OUT_1997_11)) %>%
  mutate(balance_1997_12 = balance_1997_11 + (IN_1997_12 - OUT_1997_12)) %>%
  mutate(balance_1998_1 = balance_1997_12 + (IN_1998_1 - OUT_1998_1)) %>%
  mutate(balance_1998_2 = balance_1998_1 + (IN_1998_2 - OUT_1998_2)) %>%
  mutate(balance_1998_3 = balance_1998_2 + (IN_1998_3 - OUT_1998_3)) %>%
  mutate(balance_1998_4 = balance_1998_3 + (IN_1998_4 - OUT_1998_4)) %>%
  mutate(balance_1998_5 = balance_1998_4 + (IN_1998_5 - OUT_1998_5)) %>%
  mutate(balance_1998_6 = balance_1998_5 + (IN_1998_6 - OUT_1998_6)) %>%
  mutate(balance_1998_7 = balance_1998_6 + (IN_1998_7 - OUT_1998_7)) %>%
  mutate(balance_1998_8 = balance_1998_7 + (IN_1998_8 - OUT_1998_8)) %>%
  mutate(balance_1998_9 = balance_1998_8 + (IN_1998_9 - OUT_1998_9)) %>%
  mutate(balance_1998_10 = balance_1998_9 + (IN_1998_10 - OUT_1998_10)) %>%
  mutate(balance_1998_11 = balance_1998_10 + (IN_1998_11 - OUT_1998_11)) %>%
  mutate(balance_1998_12 = balance_1998_11 + (IN_1998_12 - OUT_1998_12))

# df_transaction_mod %>%
#   filter(trans_id == 3530447)
#
# df_transaction_mod %>%
#   filter(account_id == 1 & month == 1 & year == 1996) %>%
#   arrange(desc(trans_id))

summary(transaction_cashflow_per_month_and_year)
# head(transaction_mod_balance_per_month)

```


#### Überprüfen, ob der die Überlegung so stimmt

Für den jeweiligen Kontostand Ende Monat wird eine Datumsangabe ohne Lücken benötigt. Somit kann jederzeit auch den Kontostand am Ende jeden Tages ausgeben.
Überprüfen, ob die Datumsangaben lückenlos sind.
```{r}
df_transaction_mod %>% 
  filter(
    year == 1995,
    account_id == 18
    ) %>% 
  group_by(date) %>% 
  count() %>% 
  arrange() %>% 
  nrow()

```
Am Beispiel des Accounts Nr. 18 ist klar zu erkennen, dass das Datum (mit dem dazugehörenden Kontostand) nur erfasst wurde, wenn auch eine Zahlung getätigt wurde.

Nun wird nochmals dieselbe Kontrolle mit dem Account Nr. 18 gemacht wie vor der Anreicherung und mit dem Code von Aaron verglichen.
```{r}
# Überprüfen, ob der Code von Aaron stimmt:
transaction_mod_balance_per_month %>% 
  filter(
    account_id == 18
  ) %>% 
  select(
    balance_1993_5,
    balance_1993_6,
    balance_1993_7,
    balance_1993_11,
    balance_1993_12
  )

df_transaction_mod %>% 
  filter(
    account_id == 18
  ) %>% 
  arrange(date)

```
Die Überlegung beim Code von Aaron ist falsch. 
Zum Beispiel weist der Account 18 bei Aarons Code am 1993-07-25 einen Saldo von 2600 auf aber im ursprünglichen Datensatz hat der Account zu diesem Zeitpunkt einen Saldo von 17200.0


#### Entfernen der nicht mehr benötigten Tabellen
```{r}
rm(transaction_cashflow_per_month_and_year, transaction_mod_balance_per_month)
```


## C.3. Kontostand am Ende des Tages

### 3.a. Überblick über die Anzahl Transaktionen am selben Tag über alle Observationen

Es werden nur die ersten 6 Zeilen mit den häufigsten Transaktionen am selben Tag ausgedruckt.
```{r}
df_transaction_mod %>%
  group_by(
    account_id,
    date
    ) %>%
  count() %>%
  arrange(desc(n)) %>%
  ungroup() %>% 
  head()

```
Es gibt mehrere Tage und unterschiedliche Konten, welche mehr als eine Transaktion pro Tag verzeichnet hat. Oft sind diese Tage am Ende eines Monats. Im vorliegenden Datensatz sind es maximal 7 Transaktionen pro Tag.
Die Überlegung ist nun folgende: da es sich beim vorliegenden Datensatz bei der Balance um den Betrag nach der Transaktion handelt, kann in der Umkehr der Saldo vor der Transaktion ausgerechnet werden. Dieser ausgerechnete Saldo kann im Anschluss mit dem Saldo des bestehenden Datensatzes abgeglichen werden. Somit ist schnell klar, welche Transaktion die Letzte des Tage ist und welchen Saldo das Konto am Ende des Tages aufweist. 


Dazu werden zwei Data Frames erstellt. Eines, so wie es in den Daten bereits vorhanden ist und das zweite mit gerechneten Kontoständen, um die Reihenfolge zu eruieren. Im gleichen Zug werden noch Spalten für Soll ("debit") und Haben ("credit") erstellt.

```{r}
#Erstellen der neuen Spalten debit und credit
df_transaction_mod <- df_transaction_mod %>% 
  mutate(debit = if_else(cashflow == "OUT", amount, 0)) %>% 
  mutate(credit = if_else(cashflow == "IN", amount, 0))
head(df_transaction_mod)

```
##### 3.a. Test am Account 1274

Der Account 1274 weist am 1998-11-30 sieben Zahlungen auf. Nun soll mittels Code die letzte Zahlung eruiert werden und somit auch der Kontostand am Ende des Tages.
```{r}
account1274 <- df_transaction_mod %>% 
  filter(
    account_id == 1274,
    date == "1998-11-30"
  ) %>% 
  arrange(date)
account1274

```
Um einen Kontrollwert zu erhalten, werden die Kontobewegungen von Hand ausgerechnet. Somit dient das Ergebnis als Referenzwert für die spätere Codekontrolle.
```{r}
account1274_helper <- account1274 %>% 
  mutate(balance_helper = if_else(cashflow == "IN", balance - amount, balance + amount)) %>% 
  select(
    trans_id,
    account_id,
    date,
    debit,
    credit,
    balance_helper
  ) %>% 
  rename(balance = balance_helper) %>% 
  arrange(balance)

account1274_first <- account1274 %>% 
  select(
    trans_id,
    account_id,
    date,
    debit,
    credit,
    balance
  ) %>% 
  arrange(balance)

account1274_first
account1274_helper

```

Die letzte Transaktion an diesem Tag ist die Transaktions ID 374342 mit einer Abbuchung von 30 CZK und dem Kontoendstand von 94088.0 CZK. 
Dies wird nun versucht mittels Code zu erreichen. 

```{r}

account1274_first %>% 
  anti_join(account1274_helper, by = c("account_id", "date", "balance"))

```
Somit sollte der Code funktionieren. Er kann nun auf das gesamte Data Frame df_trans_mod angewendet werden.

##### Entfernen der nicht mehr benötigeten Tabellen
```{r}
rm(account1274, account1274_first, account1274_helper)
```

#### zweite Überprüfung mit dem Konto 7418	ohne Datumseinschränkung

```{r}
# Ergänzen des bestehenden Datensatzes mit der zusätzlichen Spalte balance_end_day (Saldo nach Transaktion) und Filtern des Accounts auf die Nr. 7418
account7418	<- df_transaction_mod %>% 
  mutate(balance_end_day = balance) %>% 
  mutate(across(c(account_id, date, balance_end_day))) %>% 
  filter(account_id == 7418) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des Hilfsdatensatzes mit den Saldi vor der Transaktion
account7418_helper <- df_transaction_mod %>% 
  filter(account_id == 7418) %>% 
  mutate(balance_end_day = if_else(cashflow == "IN", balance - amount, balance + amount)) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des ersten Datensatzes ohne die Inhalte des Zweiten.
account7418_balance_end_day <- account7418 %>% 
  anti_join(account7418_helper, by = c("account_id", "date", "balance_end_day"))

# Zählen, wieviele Transkationen an einem Tag vorkommen
account7418_balance_end_day %>% 
  group_by(date) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  head()
  
```
Aus noch unerklärlichen Gründen werden nicht alle Attribute so erkannt, dass das gewünschte Ergebnis eintritt. Es sind nach wie vor maximal 5 Transaktionen pro Tag vorhanden.

Die Saldi weisen Nachkommastellen auf. Dies könnte eine mögliche Fehlerquelle sein. Deshalb wird der jeweilige Saldobetrag gerundet.
```{r}
# Entfernen der vorher generierten Datensätzen
rm(account7418, account7418_balance_end_day, account7418_helper)

# Ergänzen des bestehenden Datensatzes mit der zusätzlichen Spalte balance_end_day (Saldo nach Transaktion) mit gerundetem Betrag und Filtern des Accounts auf die Nr. 7418
account7418	<- df_transaction_mod %>% 
  mutate(balance_end_day = round(balance)) %>% 
  filter(account_id == 7418) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des Hilfsdatensatzes mit den gerundeten Saldi vor der Transaktion
account7418_helper <- df_transaction_mod %>% 
  filter(account_id == 7418) %>% 
  mutate(balance_end_day = if_else(cashflow == "IN", round(balance - amount), round(balance + amount))) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des ersten Datensatzes ohne die Inhalte des Zweiten.
account7418_balance_end_day <- account7418 %>% 
  anti_join(account7418_helper, by = c("account_id", "date", "balance_end_day"))

# Zählen, wieviele Transkationen an einem Tag vorkommen
account7418_balance_end_day %>% 
  group_by(date) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  head()

# write.csv(account7418, "..\\Test\\account7418.csv", row.names=FALSE)
# write.csv(account7418_helper, "..\\Test\\account7418_helper.csv", row.names=FALSE)
```
Es gibt nach wie vor mehrfache Transaktionen am selben Tag. Nun nur noch maximal 2. 
eine weitere Möglichkeit des Fehlers könnte im Datentyp liegen. Im vorliegenden Datensatz werden verschiedene Datentypen miteinander verglichen. Um diesen Umstand zu eliminieren werden alle Spalten für den Vergleich im Datentyp aneinander angepasst. Hierzu bietet sich der Typ character an.
```{r}
# Entfernen der vorher generierten Datensätzen
rm(account7418, account7418_balance_end_day, account7418_helper)

# Ergänzen des bestehenden Datensatzes mit der zusätzlichen Spalte balance_end_day (Saldo nach Transaktion) mit gerundetem Betrag, Typenkonvertierung in character und Filtern des Accounts auf die Nr. 7418
account7418	<- df_transaction_mod %>% 
  mutate(balance_end_day = round(balance)) %>% 
  mutate(across(c(account_id, date, balance_end_day), as.character)) %>% 
  filter(account_id == 7418) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des Hilfsdatensatzes mit den gerundeten Saldi vor der Transaktion und Typenkonvertierung in character.
account7418_helper <- df_transaction_mod %>% 
  filter(account_id == 7418) %>% 
  mutate(balance_end_day = if_else(cashflow == "IN", round(balance - amount), round(balance + amount))) %>% 
  mutate(across(c(account_id, date, balance_end_day), as.character)) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des ersten Datensatzes ohne die Inhalte des Zweiten.
account7418_balance_end_day <- account7418 %>% 
  anti_join(account7418_helper, by = c("account_id", "date", "balance_end_day"))

# Zählen, wieviele Transkationen an einem Tag vorkommen
account7418_balance_end_day %>% 
  group_by(date) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  head()

```
Die Typenkonvertierung in character hat keine Effekt gebracht.

Nun wird versucht, mit dem Datentyp factor das Ziel zu erreichen.
```{r}
# Entfernen der vorher generierten Datensätzen
rm(account7418, account7418_balance_end_day, account7418_helper)

# Ergänzen des bestehenden Datensatzes mit der zusätzlichen Spalte balance_end_day (Saldo nach Transaktion) mit gerundetem Betrag, Typenkonvertierung in factor und Filtern des Accounts auf die Nr. 7418
account7418	<- df_transaction_mod %>% 
  mutate(balance_end_day = round(balance)) %>% 
  mutate(across(c(account_id, date, balance_end_day), as.factor)) %>% 
  filter(account_id == 7418) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des Hilfsdatensatzes mit den gerundeten Saldi vor der Transaktion und Typenkonvertierung in factor.
account7418_helper <- df_transaction_mod %>% 
  filter(account_id == 7418) %>% 
  mutate(balance_end_day = if_else(cashflow == "IN", round(balance - amount), round(balance + amount))) %>% 
  mutate(across(c(account_id, date, balance_end_day), as.factor)) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des ersten Datensatzes ohne die Inhalte des Zweiten.
account7418_balance_end_day <- account7418 %>% 
  anti_join(account7418_helper, by = c("account_id", "date", "balance_end_day"))

# Zählen, wieviele Transkationen an einem Tag vorkommen
account7418_balance_end_day %>% 
  group_by(date) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  head()

```
Leider ist auch dieser Versuch negativ. Die Daten werden nun genauer untersucht.
```{r}
# Entfernen der vorher generierten Datensätzen
rm(account7418, account7418_balance_end_day, account7418_helper)

# Ergänzen des bestehenden Datensatzes mit der zusätzlichen Spalte balance_end_day (Saldo nach Transaktion) mit gerundetem Betrag und Filtern des Accounts auf die Nr. 7418
account7418	<- df_transaction_mod %>% 
  mutate(balance_end_day = round(balance)) %>% 
  filter(account_id == 7418) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des Hilfsdatensatzes mit den gerundeten Saldi vor der Transaktion
account7418_helper <- df_transaction_mod %>% 
  filter(account_id == 7418) %>% 
  mutate(balance_end_day = if_else(cashflow == "IN", round(round(balance) - round(amount)), round(round(balance) + round(amount)))) %>% 
  select(
    account_id,
    date,
    balance_end_day
  )

# Erstellen des ersten Datensatzes ohne die Inhalte des Zweiten.
account7418_balance_end_day <- account7418 %>% 
  anti_join(account7418_helper, by = c("account_id", "date", "balance_end_day"))

# Zählen, wieviele Transkationen an einem Tag vorkommen
account7418_balance_end_day %>% 
  group_by(date) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  head()

```
So wie es scheint, handelt es sich um Rundungsfehler. Denn je nach Zeitpunkt des rundens gibt es andere Ergebnisse. Dieser Umstand wird im Ursprungsdatensatz und mit gerechneten Werten verglichen.
```{r}
# Entfernen der vorher generierten Datensätzen
rm(account7418, account7418_balance_end_day, account7418_helper)

# Beträge und Saldo in zusätzlichen Spalten mit gerundeten Beträgen und Saldi vor und nach der Transaktion sowie der Dateityp in integer konvertiert.
df_transaction_mod	<- df_transaction_mod %>% 
  mutate(balance_round = round(balance)) %>% 
  mutate(amount_round = round(amount)) %>% 
  mutate(across(c("balance_round", "amount_round"), as.integer)) %>% 
  mutate(balance_before_transaction = if_else(cashflow == "IN", 
                                              balance_round - amount_round, 
                                              balance_round + amount_round)) %>% 
  mutate(balance_after_transaction = if_else(cashflow == "IN", 
                                             balance_before_transaction + amount_round, 
                                             balance_before_transaction - amount_round))

dfA <- df_transaction_mod %>% 
  mutate(balance_antijoin = balance_after_transaction) %>% 
  select(
    trans_id,
    account_id,
    date,
    balance_antijoin
  )

  
dfB <- df_transaction_mod %>% 
  mutate(balance_antijoin = balance_before_transaction) %>% 
  select(
    trans_id,
    account_id,
    date,
    balance_antijoin
  )         
  
df_antijoin <- dfA %>% 
  anti_join(dfB, by = c("account_id", "date", "balance_antijoin"))

df_antijoin %>% 
  group_by(
    account_id,
    date
  ) %>% 
  count() %>% 
  arrange(desc(n))
```
#### Überprüfen auf Rundungs- oder Rechenfehler

Es wird eine zusätzliche Spalte erstellt mit dem Vergleich der beiden Inhalte von Balance_round und Balance after transaction
```{r}
rm(dfA, dfB, df_antijoin)

df_transaction_mod <- df_transaction_mod %>% 
  mutate(balance_equal = if_else(balance_round == balance_after_transaction, TRUE, FALSE)) %>% 
  mutate(across(c("balance_equal"), as.factor))

summary(df_transaction_mod$balance_equal)
```
Es sind keine Rundungs- oder Rechenfehler vorhanden.

#### Abgleich der Saldi vor und nach der Transaktion mittels %in% Operator

```{r}
dfB <- df_transaction_mod %>% 
  select(
    account_id,
    date,
    balance_before_transaction
  ) %>% 
  group_by(
    account_id,
    date
  )

df <- df_transaction_mod %>% 
  group_by(
    account_id,
    date
  ) %>% 
  mutate(filter = df_transaction_mod$balance_round %in% dfB$balance_before_transaction)
```




#### 3.c. Erstellen der Hilfstabellen

Es werden zwei Hilfstabellen erstellt. Die erste Tabelle ist ein Data Frame mit allen Spalten des df_transaction_mod. Die zweite Tabelle wird mit der jeweiligen Account-id, dem Transaktionsdatum und dem ausgerechneten Kontostand vor der Transaktion erstellt.
```{r}

end_of_day_first <- df_transaction_mod %>% 
  mutate(balance_per_month = round(balance)) %>% 
  mutate(across(c("account_id", "date", "balance"), as.character))

end_of_day_helper <- df_transaction_mod %>%
  mutate(balance_per_month = if_else(cashflow == "IN", round(balance - amount), round(balance + amount))) %>% 
  mutate(across(c("account_id", "date", "balance"), as.character))

  
head(end_of_day_first)
head(end_of_day_helper)
```
#### 3.d. Funktion anti_join()
Nun können die beiden Hilfstabellen verglichen werden. Der jeweilige Betrag im Data Frame end_of_day_first welcher nicht auch im end_of_day_helper vorkommt, ist der Monatsendstand.
Dies wird mit der Funkton anti_join gebildet.
```{r}
balance_end_of_day <- end_of_day_first %>%
  anti_join(end_of_day_helper, by = c("account_id", "date", "balance"))
```


##### 3.e. Überprüfung
Für die erste Kontrolle werden wiederum die Account_id und das Datum gruppiert und gezählt, wieviele Transaktionen pro Tag in der Tabelle enthalten sind.
```{r}
balance_end_of_day %>%
  group_by(
    account_id,
    date
    ) %>%
  count() %>%
  arrange(desc(n)) %>% 
  ungroup()
```
Es sind immer noch mehrere Transaktionen pro Tag vorhanden. Dies wird genauer untersucht.
Dazu werden die Observationen in den verschiedenen Tabellen verglichen.

```{r}
end_of_day_first %>%
  filter(
    date == "1998-11-30",
    account_id == 9814
  )
```


```{r}
end_of_day_helper %>%
  filter(
    date == "1998-11-30",
    account_id == 9814
  )
```

```{r}
balance_end_of_day %>%
  filter(
    date == "1998-11-30",
    account_id == 9814
  )
```

```{r}
A <- end_of_day_first %>%
  filter(
    date == "1998-11-30",
    account_id == 9814
  ) %>%
  select(account_id, date, balance)

B <- end_of_day_helper %>%
  filter(
    date == "1998-11-30",
    account_id == 9814
  ) %>%
  select(account_id, date, balance)

C <- balance_end_of_day %>%
  filter(
    date == "1998-11-30",
    account_id == 9814
  ) %>%
  select(account_id, date, balance)

```


```{r}
anti_join(A, B, by = c("balance"))
```
```{r}
glimpse(A)
```
```{r}
glimpse(B)
```
```{r}
anti_join(A, B, by = 'balance')
```
```{r}
rm(A,B,C)
```

```{r}
df1 <- data.frame(team=c('C', 'D', 'E','A', 'B'),
                  points=c(21501.9, 14, 19, 24, 21487.3))

df2 <- data.frame(team=c('A', 'B', 'C', 'F', 'G'),
                  points=c(12, 14, 21402.7, 33, 21501.9))

anti_join(df1, df2, by='points')
```

```{r}
rm(df1,df2)
```


##### Kontrolle mit Account 1274


```{r}
balance_end_of_day %>%
  filter(
      account_id == 1274,
      date == "1998-11-30"
    )
```

#### Anreichern der fehlenden Daten in den Attributen "Date" und "Balance"

Nach den eben gewonnenen Erkenntnissen werden nun das Datum und der Kontostand an den fehlenden Tagen ergänzt.
```{r}
# balance_end_of_day <- balance_end_of_day %>%
#   group_by(account_id) %>%
#   complete(date = seq.Date(min(date), max(date), by = "day")) 
# # %>%
# #   fill(balance)
# 
# balance_end_of_day %>% 
#   filter(
#       account_id == 1,
#       date == "1995-08-31"
#     )

```

#### Anfügen der Kontostände an das df_transaction_mod
```{r}
# balance_end_of_day_join <- balance_end_of_day %>% 
#   select(
#     trans_id,
#     balance
#   ) %>% 
#   rename(balance_end_of_day = balance)
# 
# df_transaction_mod <- left_join(df_transaction_mod, balance_end_of_day_join, by = "trans_id")

```

#### Entfernen der nicht mehr benötigten Tabellen
```{r}
# rm(balance_end_of_day, balance_end_of_day_join)
```

```{r}
# df_transaction_mod %>% 
#   filter(
#     account_id == 1,
#     date == "1996-05-13"
  # )
```
#### NA's in balance_end_of_day

Die NA's in balance_end_of_day sind überall dort entstanden, wo es mehrere Zahlungen am selben Tag gibt und die Zahlung nicht die letzte war. Dies kann nun komplettiert werden zusammen mit dem Ergänzen der Tage. Somit wird ein lückenloser Ablauf der Kontobewegungen erreicht.

#### Anreichern der fehlenden Daten in den Attributen "Date" und "Balance"

Nach den eben gewonnenen Erkenntnissen werden nun das Datum und der Kontostand an den fehlenden Tagen ergänzt.
```{r}
# df_transaction_mod_complete <- df_transaction_mod %>% 
#   group_by(account_id) %>% 
#   complete(date = seq.Date(min(date), max(date), by = "day")) %>% 
#   fill(balance_end_of_day,
#        year,
#        month)
# 
# head(df_transaction_mod_complete)

```
```{r}
# df_transaction_mod_complete %>% 
#   filter(
#     account_id == 1,
#     date == "1996-05-13"
#   )
```
Die Anreicherung der Daten nimmt jeweils den letzten Betrag und führt diesen weiter. Da die Reihenfolge aber so nicht mit den Transaktionen übereinstimmt, muss für das Anreichern jeweils das Datum und der Account gruppiert werden. 
```{r}
# df_transaction_mod_complete <- df_transaction_mod %>% 
#   group_by(account_id) %>% 
#   complete(date = seq.Date(min(date), max(date), by = "day")) %>% 
#   ungroup() %>% 
#   arrange(
#     account_id,
#     date
#   )
# 
# head(df_transaction_mod_complete)

```

```{r}
# df_transaction_mod_complete <- df_transaction_mod_complete %>% 
#   group_by(
#     account_id,
#     date
#   ) %>% 
#   fill(year,
#        month,
#        balance_end_of_day
#        )
# 
# head(df_transaction_mod_complete)
```

```{r}
# df_transaction_mod_complete %>% 
#   filter(
#     account_id == 1,
#     date == "1996-05-13"
#   )
```







