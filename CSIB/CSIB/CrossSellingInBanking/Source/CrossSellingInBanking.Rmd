---
title: '<br>
 <img style="background: #FDE70F;" src="https://www.fhnw.ch/de/++theme++web16theme/assets/media/img/fachhochschule-nordwestschweiz-fhnw-logo.svg" alt="FHNW Logo" height="50rem" id="logo">
  <br><br>Challenge: Cross Selling in Banking (CED1)'
author: Gisler Luca, Heeb Christian, Studer Aaron, Bécheiraz Léonie
date: "`r format(Sys.time(), '%d.%m.%y')`"
output:
   html_document:
      toc: true
      toc_depth: 6
      toc_float: true
      collapsed: false
      code_folding: show
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE,
                      warning = FALSE)
```

```{=html}
<style type="text/css" media="screen">
h1, h2, h3 {
    color: #4D4D4D;
   }

.list-group-item.active {
    background-color: #FDE70F;
    border-color: #FDE70F;
    color: #4D4D4D;
    font-weight: bold;
}

#logo {
    padding-left: 1rem;
}

</style>
```
## Aufgabenstellung

### Allgemein

Eine tschechische Bank möchte ihre Dienstleistungen für Privatkunden
verbessern und "interessante Kundengruppen" identifizieren. Die
Geschäftsleitung hat keine präzise Vorstellung, möchte aber zusätzliches
Business generieren ohne unnötige Risiken einzugehen und Verluste
einzufahren.

Der analytische Auftrag umfasst die folgenden Aufgaben:

-   Qualität und Repräsentativität der Daten zu überprüfen
-   Die Verteilung der einzelnen Datenattribute zu erheben
-   Deren Veränderung über die Zeit zu analysieren
-   Korrelationen zwischen verschiedenen Datenattributen zu
    quantifizieren und zu visualisieren sowie Hypothesen hinsichtlich
    optimaler Produktverkauf / -nutzung zu erstellen

### Datengrundlage

Wir erhalten die Daten von einer Tschechischen Bank. Die Datengrundlage
ist auf [dieser
Webseite](https://sorry.vse.cz/~berka/challenge/PAST/index.html)
beschrieben.

## Datenbeschreibung

Die Datengrundlage enthält 8 verschiedene Tabellen (Data Frames) im .csv
Format mit Total 47 Attributen. Diese Tabellen mit den jeweiligen
Attributen werden hier genauer beschrieben.

Relation disposition (df_raw_disposition): disp_id: record identifier\
client_id: identification of a client\
account_id: identification of an account\
type: type of disposition (owner/user) only owner can issue permanent
orders and ask for a loan

#### ERD Daten IST-Zustand

![ERD Daten IST-Zustand](../Ressources/IST-Zustand.png)

## Setup

```{r}
library(tidyverse)
library(ggmosaic)
library(ggalluvial)
library(DALEXtra)
library(visdat)
library(DT)
library(patchwork)
library(ggpubr)
library(rpart.plot)
library(tidymodels)
library(lubridate)
library(cluster)
library(imputeTS)
tidymodels_prefer()
```

### Setup Account Data Frame

In diesem Schritt wird das Data Frame Account vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}

df_raw_account <- read.csv("../xselling_banking_data/account.csv", header = TRUE, sep = ";")

str(df_raw_account)

```

Es wird wie folgt die Spalte 'date' von dem Type Integer zu dem Typ Date
umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Spalte 'frequency'
ist eine kategoriale Variable mit Tschechischen Werten, daher
transformieren wir auch diese Werte auf Englisch.

```{r}

df_account <- df_raw_account %>%
  mutate(date = ymd(date)) %>%
  mutate(frequency = case_when(frequency == "POPLATEK MESICNE" ~ "Monthly",
                              frequency == "POPLATEK TYDNE" ~ "Weekly",
                              frequency == "POPLATEK PO OBRATU" ~ "After_Transaction")
  ) %>%
  arrange(account_id)

rm(df_raw_account)
```

### Setup Client Data Frame

In diesem Schritt wird das Data Frame Account vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_client <- read.csv("../xselling_banking_data/client.csv", header = TRUE, sep = ";")

str(df_raw_client)

```

Es wird wie folgt die Spalte 'birth_number' von dem Type Integer zu dem
Typ Date umgewandelt, zusätzlich nennen wir die Spalte neu
'dateofbirth'. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Es wird eine neue Spalte
'sex' hinzugefügt, mithilfe der Dokumentation der Daten kennen wir die
Kondition, welches Geschlecht der Kunde hat.

```{r}

df_client <- df_raw_client %>%
  mutate(dateofbirth = case_when(
    strtoi(substr(as.character(birth_number), 3, 3)) > 1 ~ (ymd(birth_number - 5000)),
    TRUE ~ (ymd(birth_number)),
  )) %>%
  mutate(sex = case_when(
    strtoi(substr(as.character(birth_number), 3, 3)) > 1 ~ "Female",
    TRUE  ~ "Male"
  ))

df_client <- df_client %>%
 mutate(dateofbirth = case_when(
   year(ymd(dateofbirth)) > 2000 ~ ymd(dateofbirth) - years(100),
   TRUE ~ ymd(dateofbirth)
 )) %>%
 select(client_id, district_id, dateofbirth, sex) %>%
 arrange(client_id) 

rm(df_raw_client)
```

### Setup Disposition Data Frame

In diesem Schritt wird das Data Frame Disposition vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_disposition <- read.csv("../xselling_banking_data/disp.csv", header = TRUE, sep = ";")

str(df_raw_disposition)

```

In dem Date Frame disposition müssen keine weitere Schritte erledigt
werden für das Transformieren der Daten.

```{r}

df_disposition <- df_raw_disposition %>%
 select(disp_id, client_id, account_id, type) %>%
 arrange(disp_id) 

rm(df_raw_disposition)
```

### Setup Order Data Frame

In diesem Schritt wird das Data Frame Order vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_perm_order <- read.csv("../xselling_banking_data/order.csv", header = TRUE, sep = ";")

str(df_raw_perm_order)

```

In dem Data Frame perm_order müssen wir die kategoriale Variable
'k_symbol' noch übersetzen, da der Name 'k_symbol' nicht ausschlaggeben
ist, benennen wir die Spalte zu 'payment_type' um.

```{r}

df_perm_order <- df_raw_perm_order %>%
 mutate(payment_type = case_when(k_symbol == "POJISTNE" ~ "INSURRANCE",
                              k_symbol == "SIPO" ~ "HOUSEHOLD",
                              k_symbol == "LEASING" ~ "LEASING",
                              k_symbol == "UVER" ~ "LOAN",
                              TRUE ~ "UNKNOWN")
 ) %>%
 select(order_id, account_id, bank_to, account_to, amount, payment_type) %>%
 arrange(order_id) 

rm(df_raw_perm_order)
```

### Setup Transaction Data Frame

In diesem Schritt wird das Data Frame Transaction vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_transaction <- read.csv("../xselling_banking_data/trans.csv", header = TRUE, sep = ";")

str(df_raw_transaction)

```

Es wird wie folgt die Spalte 'date' von dem Type Integer zu dem Typ Date
umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Spalte 'type' muss
von Tschechisch noch auf Englisch übersetzt werden. Dasselbe zählt auch
für die Spalte 'operation' und 'k_symbol'. Jedoch benennen wir die
Splate 'k_symbol' noch um in die neue Spalte 'characterization'.

```{r}

df_transaction <- df_raw_transaction %>%
 mutate(date = ymd(date)) %>%
 mutate(type = case_when(type == "PRIJEM" ~ "CREDIT",
                         type == "VYDAJ" ~ "WITHDRAWAL") 
 ) %>%
 mutate(operation = case_when(operation == "VYBER KARTOU" ~ "CREDIT CARD WITHDRAWAL",
                              operation == "VKLAD" ~ "CASH CREDIT",
                              operation == "PREVOD Z UCTU" ~ "COLLECTION OTHER BANK",
                              operation == "VYBER" ~ "CASH WIDTHDRAWAL",
                              operation == "PREVOD NA UCET" ~ "REMITTANCE OTHER BANK")
 ) %>%
 mutate(characterization = case_when(k_symbol == "POJISTNE" ~ "INSURRANCE PAYMENT",
                              k_symbol == "SLUZBY" ~ "STATEMENT PAYMENT",
                              k_symbol == "UROK" ~ "CREDIT INTEREST",
                              k_symbol == "SANKC. UROK" ~ "SANCTION INTEREST",
                              k_symbol == "SIPO" ~ "HOUSEHOLD",
                              k_symbol == "DUCHOD" ~ "OLD AGE PENSION",
                              k_symbol == "UVER" ~ "LOAN PAYMENT")
 ) %>%
 select(trans_id, account_id, date, type, operation, amount, balance, characterization, bank, account) %>%
 arrange(trans_id) 

rm(df_raw_transaction)
```

### Setup Loan Data Frame

In diesem Schritt wird das Data Frame Loan vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_loan <- read.csv("../xselling_banking_data/loan.csv", header = TRUE, sep = ";")

str(df_raw_loan)

```

Es wird wie folgt die Spalte 'date' von dem Type Integer zu dem Typ Date
umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Spalte 'status'
besitzt Enum-Werte. Diese Werte transformieren wir von A, B, C und D zu
den entsprechenden Bedeutungen auf English.

```{r}

df_loan <- df_raw_loan %>%
 mutate(date = ymd(date)) %>%
 mutate(status = case_when(status == "A" ~ "CONTRACT FINISHED PAYED",
                              status == "B" ~ "CONTRACT FINISHED UNPAID",
                              status == "C" ~ "CONTRACT OPEN OK",
                              status == "D" ~ "CONTRACT OPEN INDEBT",
                              TRUE ~ "")
 ) %>%
 select(loan_id, account_id, date, amount, duration, payments, status) %>%
 arrange(loan_id) 

rm(df_raw_loan)
```

### Setup Credit Card Data Frame

In diesem Schritt wird das Data Frame Credit Card vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_credit_card <- read.csv("../xselling_banking_data/card.csv", header = TRUE, sep = ";")

str(df_raw_credit_card)

```

Es wird wie folgt die Spalte 'issued' von dem Type Character zu dem Typ
Date umgewandelt. Dabei brauchen wir die Funktionalitäten von
[Lubridate](https://lubridate.tidyverse.org/). Die Werte der Spalte
'type' werden in Upper Case umgeschrieben für eine klarere Übersicht von
kategorialen Variablen über alle Data Frames.

```{r}

df_credit_card <- df_raw_credit_card %>%
 mutate(issued  = ymd(as.integer(substr(issued, 0, 6)))) %>%
 mutate(type = case_when(type == "junior" ~ "JUNIOR",
                              type == "classic" ~ "CLASSIC",
                              type == "gold" ~ "GOLD",
                              TRUE ~ "")
 ) %>%
 select(card_id, disp_id, type, issued) %>%
 arrange(card_id) 

rm(df_raw_credit_card)
```

### Setup District Data Frame

In diesem Schritt wird das Data Frame District vorbereitet und der
'Transform'-Schritt wird durchgeführt.

```{r}
df_raw_district <- read.csv("../xselling_banking_data/district.csv", header = TRUE, sep = ";")

str(df_raw_district)

```

In dem Date Frame 'district' müssen wir alle Spalten neu benennnen, da
die einzelnen Spalten aus der Datenquelle keine Aussage über die Daten
drinhat. Daher geben wir jeder Spalte einen passenden Namen.

```{r}

df_district <- df_raw_district %>%
 mutate(district_id  = A1) %>%
 mutate(name = A2) %>%
 mutate(region = A3) %>%
 mutate(inhabitants = A4) %>%
 mutate(municipalities_under_499_inhabitants = A5) %>%
 mutate(municipalities_500_to_1999_inhabitants = A6) %>%
 mutate(municipalities_2000_to_9999_inhabitants = A7) %>%
 mutate(municipalities_over_10000_inhabitants = A7) %>%
 mutate(cities = A9) %>%
 mutate(ratio_urban_inhabitants = A10) %>%
 mutate(average_salary = A11) %>%
 mutate(unemployment_rate_95 = A12) %>%
 mutate(unemployment_rate_96 = A13) %>%
 mutate(enterpreneurs_per_1000_inhabitants = A14) %>%
 mutate(commited_crimes_95 = A15) %>%
 mutate(commited_crimes_96 = A16) %>%
 select(district_id, name, region, inhabitants, municipalities_under_499_inhabitants, municipalities_500_to_1999_inhabitants, municipalities_2000_to_9999_inhabitants, municipalities_over_10000_inhabitants, cities, ratio_urban_inhabitants, average_salary, unemployment_rate_95, unemployment_rate_96, enterpreneurs_per_1000_inhabitants, commited_crimes_95, commited_crimes_96) %>%
 arrange(district_id) 

rm(df_raw_district)
```

### ERD Ist-Zustand

In dem nachfolgend Enitity Relation Diagramm sieht man die Elemente der
transformierten Daten.

![ERD Daten IST-Zustand](../Ressources/SOLL-Zustand.png)

## 1. Tabellen zusammenführen und erste Analysen

### Tabellen vorbereiten

Die einzelnen Tabellen werden vor dem Zusammenführen so vorbereitet,
dass pro Account nur eine Zeile vorhanden ist.

#### Data Frame "Permanent Order"

```{r}

summary(df_perm_order)
```

```{r}
str(df_perm_order)
```
Neuorganisation der Werte aus "payment_type" in Spalten mit der Summe der Beträge "amount" und ergänzenden Spalten mit der Information, wieviele Aufträge des gleichen Typs vorhanden sind. 
Die Spalten "order_id", "bank_to" und "account_to" werden weggelassen, da diese für die zukünftigen Analysen nicht benötigt werden.
```{r}
# summe der Beträge
df_perm_order_mod <- df_perm_order %>% 
  group_by(
    account_id,
    payment_type
  ) %>% 
  mutate(amount_sum = sum(amount)) %>% 
  group_by(
    account_id,
    payment_type,
    amount_sum
  ) %>% 
  count() %>% 
  rename(payment_type_num = n) %>% 
  pivot_wider(names_from = payment_type, values_from = c(amount_sum, payment_type_num)) %>% 
  na.replace(., 0)

# str(df_perm_order_mod)

if (!grepl("order.", names(df_perm_order_mod)[2])) {
names(df_perm_order_mod) <- paste0("order.", names(df_perm_order_mod))
}
```

Überprüfung der bisher nicht beachteten Spalten "bank_to" und "account_to"
```{r}
df_perm_order %>% 
  group_by(
    bank_to, 
    account_to
  ) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  head()
```

```{r}
df_perm_order %>% 
  filter(
    account_to == 79838293
  )
```
Es gibt Überweisungen, welche von verschiedenen Konten (maximal 2) auf dasselbe Ziel-Konto einzahlen. Für die Analysen, welche geplant sind, ist dieser Umstand nicht relevant. Deshalb werden diese Informationen vorerst weggelassen. Falls nötig, können sie zu einem späteren Zeitpunkt immer noch dazu genommen werden.


#### Data Frame "Account"

Das Data Frame Account steht im Zentrum und beinhaltet die
Schlüsselfelder zu fast allen weiteren Tabellen. Deshalb beginnen wir
mit dem Account.
```{r}
summary(df_account)
```
Die Werte der Spalte "frequency" werden in Faktoren umgewandelt. Zudem werden zusätzliche Spalten für die Kontoeröffnungsdaten erstellt (-> Eröffnungsjahr als "opening_year", Eröffnungsmonat als "opening_month") und die Spalte "date" in "opening_date" geändert.
Anschliessend wird wieder allen Spalten das Präfix "account." erteilt.

```{r}
df_account_mod <- df_account %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(opening_year = year(date)) %>%
  mutate(opening_month = month(date)) %>%
  rename("opening_date" = "date")



if (!grepl("account.", names(df_account_mod)[2])) {
names(df_account_mod) <- paste0("account.", names(df_account_mod))
}
```

### Erstes Zusammenführen 

Erstes zusammenfügen der modifizierten Data Frames "df_account_mod" und "df_perm_order_mod" zum neuen Data Frame "df_mod".
```{r}

df_mod <- left_join(df_account_mod, df_perm_order_mod, by = c( "account.account_id" = "order.account_id"))

summary(df_mod)

```
Die NA's in den Spalten von "order." bedeuten, dass bei diesen Konten keine Daueraufträge hinderlegt sind. Die Zahl 0 (Null) bedeutet, dass zwar Daueraufträge hinterlegt sind, aber nicht zu diesem Themenbereich.

Nun können die nicht mehr benötigten Tabellen aus dem Global Environment entfernt werden.
```{r}
rm(df_account, df_account_mod, df_perm_order, df_perm_order_mod)
```


#### Data Frame "Loan"

Im weiteren Schritt wird das Data Frame "Loan" vorbereitet.
Übersicht über das Data Frame
```{r}
glimpse(df_loan)
```

Folgendes soll angepasst werden:
- die Spalte "status" wird in Faktor umgewandelt. 

- Umbenennen der Spalten:
  - "duration" zu "duration_in_month"
  - "date" zu "start_date"
  - "amount" zu "total_amount"
  - "payments" zu "redemption_amount"
  
- Zusätzliche Spalte:
  - "duration_in_years" generiert aus "duration_in_month" mit den Ganzzahlen für 
    12 = 1,
    24 = 2,
    36 = 3,
    48 = 4,
    60 = 5
  - "end_date" gerechnet aus "start_date" plus "duration_in_years"
  - "in_dept" generiert aus der Spalte "status" für
    "CONTRACT FINISHED PAYED" und "CONTRACT OPEN OK" = "NO"
    "CONTRACT FINISHED UNPAID" und "CONTRACT OPEN INDEBT" = "YES"
  
```{r}
df_loan_mod <- df_loan %>%
  # mutate(across(c(status), as.factor)) %>%
  rename(
    "duration_in_month" = "duration",
    "start_date" = "date",
    "total_amount" = "amount",
    "redemption_amount" = "payments"
    ) %>%
  mutate(
    duration_in_years = case_when(
                                  duration_in_month == 12 ~ 1,
                                  duration_in_month == 24 ~ 2,
                                  duration_in_month == 36 ~ 3,
                                  duration_in_month == 48 ~ 4,
                                  duration_in_month == 60 ~ 5
  )) %>%
  mutate(end_date = start_date + years(duration_in_years)) %>%
  mutate(in_dept = if_else(c(status == "CONTRACT FINISHED PAYED" |
                             status == "CONTRACT OPEN OK"), "NO", "YES")) %>%
  mutate(across(where(is.character), as.factor)) %>%
  relocate(end_date, .after = start_date) %>%
  relocate(starts_with("duration"), .after = end_date)

  # levels(df_loan_mod$status)

```

Überprüfung, ob ein Account mehrere Darlehen hat.
```{r}
df_loan_mod %>%
  group_by(account_id) %>%
  count() %>%
  arrange(desc(n)) %>%
  head()

```

Da es pro Account nur jeweils 1 Darlehensvertrag gibt, braucht es für diese Tabelle keine weiteren Anpassungen.
Es wird nur noch das Präfix "loan." hizugefügt, bevor ein Anfügen an die Gesamttabelle erfolgt.
```{r}
if (!grepl("loan.", names(df_loan_mod)[2])) {
names(df_loan_mod) <- paste0("loan.", names(df_loan_mod))
}

```
 
 ### Zweites Zusammenführen

 Loan wird zum Data Frame "df_mod" hinzugefügt.
```{r}
df_mod <- left_join(df_mod, df_loan_mod, by = c("account.account_id" = "loan.account_id"))
 
summary(df_mod)
 
```

Die NA's in den Spalten von "loan." bedeuten, dass bei diesen Konten keine Darlehen hinderlegt sind, analog den Informationen aus den Spalten "order."
 
Entfernen der nicht mehr benötigten Tabellen aus dem Global Environment.
```{r}
rm(df_loan, df_loan_mod)

```

 
#### Data Frame "disposition"
 
Übersicht über das Data Frame
```{r}
glimpse(df_disposition)
```
Werte in type umbenennen (Disponent zu User)
neue Spalte mit Anzahl Benutzer pro Konto (account_user_num)
Werte der Spalte type in neue Spalten aufteilen mit Bezeichnung und Werten aus client_id und disp_id
```{r}
df_disposition_mod <- df_disposition %>% 
   mutate(type = ifelse(c(type == "OWNER"), "OWNER", "USER")) %>% 
   pivot_wider(names_from = type, values_from = c(client_id, disp_id))

#Spalte mit Anzahl User pro Account
df_disposition_num_user <- df_disposition %>% 
  group_by(
    account_id
  ) %>% 
  count() %>% 
  rename(account.num_of_user = n)

#Anfügen der neuen Spalte "account.num_of_user" an das df_disposition_mod
df_disposition_mod <- left_join(df_disposition_mod, df_disposition_num_user, by = "account_id")

summary(df_disposition_mod)
 
```
Die NA's in den Spalten mit den User-Daten kommen daher, dass bei diesen Accounts nur 1 Benutzer (Owner) eingetragen ist.
 
Wiederum wird den Spalten ein Präfix hinzugefügt (disp.)
```{r}
if (!grepl("disp.", names(df_disposition_mod )[2])) {
names(df_disposition_mod) <- paste0("disp.", names(df_disposition_mod))
}

```
 
### Drittes Zusammenführen
 
```{r}
df_mod <- left_join(df_mod, df_disposition_mod, by = c("account.account_id" = "disp.account_id"))

glimpse(df_mod)

```
Entfernen der nicht mehr benötigten Tabellen
```{r}
rm(df_disposition, df_disposition_mod, df_disposition_num_user)
```

#### Data Frame "credit card"
```{r}
glimpse(df_credit_card)
```
Hier braucht es nur eine Umformung der Spalte "type" in Faktor und das Anfügen des Präfixes (card.)
```{r}
df_credit_card_mod <- df_credit_card %>% 
   mutate(across(where(is.character), as.factor))

if (!grepl("card.", names(df_credit_card_mod)[2])) {
names(df_credit_card_mod) <- paste0("card.", names(df_credit_card_mod))
}
    
glimpse(df_credit_card_mod)

```
 
### Viertes Zusammenführen
```{r}
df_mod <- left_join(df_mod, df_credit_card_mod, by = c("disp.disp_id_OWNER" = "card.disp_id"))
 
glimpse(df_mod)
 
```
 
Überprüfen, ob alle Kreditkarten übernommen wurden
```{r}
summary(df_mod$card.type)
```
Gesamthaft wurden 892 Kreditkarten-Informationen übernommen.
 
Entfernen der nicht mehr benötigten Tabellen.
```{r}
rm(df_credit_card, df_credit_card_mod)
```
 
#### Data Frame "client"

```{r}
glimpse(df_client)
```
Bei dieser Tabelle wird das Geschlecht in Faktoren umgewandelt und eine zusätzliche Spalte für das Alter bei der Kontoeröffnung erstellt. Diese zusätzliche Spalte kann erst nach dem Zusammenfügen mit den Account-Daten generiert werden.
Danach können die Informationen in df_mod eingefügt werden. Dazu werden zwei verschiedene Tabellen erstellt, eine für Owner und eine für den User.
```{r}
df_client_mod <- df_client %>% 
 mutate(across(where(is.character), as.factor))
 
df_client_user <- df_client_mod
df_client_owner <- df_client_mod

if (!grepl("user.", names(df_client_user)[2])) {
names(df_client_user) <- paste0("user.", names(df_client_user))
}
 
if (!grepl("owner.", names(df_client_owner)[2])) {
names(df_client_owner) <- paste0("owner.", names(df_client_owner))
}
 
```
 
### Fünftes Zusammenführen

```{r}
df_mod <- left_join(df_mod, df_client_owner, by = c("disp.client_id_OWNER" = "owner.client_id"))
df_mod <- left_join(df_mod, df_client_user, by = c("disp.client_id_USER" = "user.client_id"))
```

Entfernen der nicht mehr benötigten Tabellen "client"
```{r}
rm(df_client, df_client_mod, df_client_owner, df_client_user)
```
Spalten werden neu angeordnet und wo sinnvoll, umbenannt:

Umbenennen:
- disp.client_id_OWNER wird zu owner.client_id,
- disp.client_id_USER wird zu user.client_id,
- disp.disp_id_OWNER wird zu owner.disp_id,
- disp.disp_id_USER wird zu user.disp_id,
- card.card_id wird zu card.id,
- loan.loan_id wird zu loan.id,
- account.account_id wird zu account.id,
-   order.amount_sum_HOUSEHOLD wird zu owner.client_id,
-   order.amount_sum_INSURRANCE wird zu order.amount_insurrance,
-   order.amount_sum_LOAN wird zu order.amount_loan,
-   order.amount_sum_UNKNOWN wird zu order.amount_unknown,
-   order.amount_sum_LEASING wird zu order.amount_leasing,
-   order.payment_type_num_HOUSEHOLD wird zu order.num_household,
-   order.payment_type_num_INSURRANCE wird zu order.num_insurrance,
-   order.payment_type_num_LOAN wird zu order.num_loan,
-   order.payment_type_num_UNKNOWN wird zu order.num_unknown,
-   order.payment_type_num_LEASING wird zu order.num_leasing

```{r}
# Spalten umbenennen und neu anordnen
df_mod  <- df_mod %>%
 rename(
   owner.client_id = disp.client_id_OWNER,
   user.client_id = disp.client_id_USER,
   owner.disp_id = disp.disp_id_OWNER,
   user.disp_id = disp.disp_id_USER,
   card.id = card.card_id,
   loan.id = loan.loan_id,
   account.id = account.account_id,
   account.num_of_user = disp.account.num_of_user,
   order.total_amount_household = order.amount_sum_HOUSEHOLD,
   order.total_amount_insurrance = order.amount_sum_INSURRANCE,
   order.total_amount_loan = order.amount_sum_LOAN,
   order.total_amount_unknown = order.amount_sum_UNKNOWN,
   order.total_amount_leasing = order.amount_sum_LEASING,
   order.num_household = order.payment_type_num_HOUSEHOLD,
   order.num_insurrance = order.payment_type_num_INSURRANCE,
   order.num_loan = order.payment_type_num_LOAN,
   order.num_unknown = order.payment_type_num_UNKNOWN,
   order.num_leasing = order.payment_type_num_LEASING
 ) 

#zusätzliche Spalte erstellen für das Alter der Owner bei der Kontoeröffnung.
df_mod <- df_mod %>% 
  mutate(owner.age_at_account_opening = round(as.numeric(account.opening_date - owner.dateofbirth)/365)) %>% 
  mutate(user.age_at_account_opening = round(as.numeric(account.opening_date - user.dateofbirth)/365))
```

#### Data Frame "District"

Übersicht über das Data Frame.
```{r}
glimpse(df_district)
```
unemployment_rate_95 in dbl
commited_crimes_95 in int
anschliessend alle chr in factor

```{r}
df_district <- df_district %>% 
  mutate(across(c(unemployment_rate_95), as.double),
         across(c(commited_crimes_95), as.integer),
         across(where(is.character), as.factor))

glimpse(df_district)
```
Erstellen des Data Frames für den Import in das "df_mod"
```{r}

df_district_mod <- df_district

if (!grepl("district.", names(df_district_mod )[2])) {
names(df_district_mod) <- paste0("district.", names(df_district_mod))
}

#Auswahl der Spalten für den Übertrag
df_district_select <- df_district_mod %>% 
  select(
    district.district_id,
    district.name,
    district.region,
    district.average_salary,
    district.inhabitants
  )

#Erstellen von zwei Data Frames für Account und Owner
df_district_account <- df_district_select
if (!grepl("account.", names(df_district_account )[2])) {
names(df_district_account) <- paste0("account.", names(df_district_account))
}

df_district_owner <- df_district_select
if (!grepl("owner.", names(df_district_owner )[2])) {
names(df_district_owner) <- paste0("owner.", names(df_district_owner))
}

```

Die vorbereiteten Observationen können nun dem df_mod hinzugefügt werden.
```{r}
df_mod <- left_join(df_mod, df_district_account, by = c("account.district_id" = "account.district.district_id"))

df_mod <- left_join(df_mod, df_district_owner, by = c("account.district_id" = "owner.district.district_id"))
```

Entfernen der nicht mehr benötigten Tabellen.
```{r}
rm(df_district, df_district_account, df_district_owner, df_district_select)
```

Für das konsolidierte Data Frame werden die Spalten neu angeordnet.
```{r}
#dieser Code verwenden, um das df_cons zu erstellen
df_mod <- df_mod %>%
  relocate(starts_with("account")) %>% 
  relocate(starts_with("owner."), .after = last_col()) %>%
  relocate(starts_with("user."), .after = last_col()) %>%
  relocate(contains("id"), .after = last_col()) %>% 
  relocate(account.id)

glimpse(df_mod)

```

```{r}
#für die Transaktionen nur 1 Account pro Zeile. Wenn mehrere Benutzer auf einem Account: Group by account id und count. Dann die Anzahl als neue Spalte beim Account anfügen mit mutate. Wenn nötig über Hilfs df und dann mittels Account id und %in% einfügen. 
#Kontostand auf jeweils Ende Monat
#Summe pro Monat wie viel rein kommt / raus geht
#Quartalsbezeichnung
#Können bereits vorhandene Produkte der Bank bezeichnet werden? Wenn JA, Spalte mit Produkten erstellen (z.B. Kunde hat Kreditkarte JA/Nein -> credit card_holder)

```

### Sonderstellung: Bedeutung des Account Owner

Wie wir bei der Datenbeschreibung bereits gelesen haben, enthält
disposition_type die Information über die Rechte der Konten. Deshalb
wurde  der Eintrag "disponent" in "user" geändert. Denn nur der
"owner" hat die nötigen Berechtigungen, um Daueraufträge zu erteilen und
Darlehen zu beantragen.

```{r}

```


### Auf Duplikate überprüfen

```{r}
n_distinct(df_mod)
```
Es sind keine Duplikate vorhanden.

#### Data Frame "transaction"

Übersicht über die Tabelle
```{r}
glimpse(df_transaction)

```
Typen ändern von Character in Factors.
```{r}
df_transaction_mod <- df_transaction %>% 
  mutate(across(where(is.character), as.factor))

summary(df_transaction_mod)

```
Spalten umbenennen:
- bank wird zu bank_name
- account wird zu account_nr
- type wird zu cashflow

```{r}
df_transaction_mod <- df_transaction_mod %>% 
  rename(
    bank_name = bank,
    account_nr = account,
    cashflow = type
  )
```

#### Untersuchen der NA's

Als erstes beginnen wir mit der neu benannten Spalte cashflow
```{r}
df_transaction_mod %>% 
  filter(is.na(cashflow)) %>% 
  summary()
```
Die NA's in "cashflow" und "characterization" sind Geldausgänge und können deshalb als Werte in die beiden Spalten imputiert werden. Bei der Spalte "bank_name" fällt auf, dass die Werte leer sind. Deshalb wird dort mit NA's ergänzt.
Es könnte sich bei diesen Geldbezügen um Bezüge an den Automaten handeln. Dies kann aber erst überprüft werden, wenn diese Informationen mit den Beobachtungen aus der Tabelle mit den Kreditkarten-Informationen abgeglichen werden kann.
Diese Analyse kann zu einem späteren Zeitpunkt vorgenommen werden.

```{r}
#Liste für die gezielte Imputation in "characterization" mit "CASH WIDTHDRAWAL"
list_na_characterization_for_cashwidthrawal <- df_transaction_mod %>% 
  filter(is.na(cashflow)) %>% 
  select(trans_id)

list_transid_for_imputation <- as.list(list_na_characterization_for_cashwidthrawal)
```


#### Imputieren
```{r}
df_transaction_mod <- df_transaction_mod %>% 
  mutate(cashflow = case_when(cashflow == "WITHDRAWAL" ~ "OUT",
                              cashflow == "CREDIT" ~ "IN",
                              TRUE ~ "OUT")) %>%
  mutate(across(where(is.character), as.factor))

# das Imputieren der Werte in characterization geschieht mit %in% dazu muss der Code noch gefunden werden. Ist für den Moment nicht so dringend. Für dieses Imputieren wurde die Liste list_na_characterization_for_cashwidthrawal erstellt

n_row_na <- nrow(list_na_characterization_for_cashwidthrawal)
  
```

Kontostand Ende Monat

```{r}
# balance_end_of_month  <- df_transaction_mod %>% 
#   mutate(
#     year = year(date),
#     month = month(date)
#   ) %>% 
#   group_by(
#     account_id,
#     year,
#     month
#   ) %>% 
#   arrange(desc(trans_id)) %>% 
#   slice_head(n = 1)
# 
# balance_end_of_month_select <- df_transaction_mod %>% 
#   filter(
#     trans_id %in% balance_end_of_month$trans_id
#   ) %>% 
#   select(
#     account_id,
#     date,
#     balance,
#     ) %>% 
#   arrange(date) %>% 
#   pivot_wider(names_from = date, values_from = balance)
  
# balance_end_of_month_select <- balance_end_of_month_select %>%  
#   pivot_wider(names_from = date, values_from = balance)
```

Bilanz Ende Jahr
```{r}
df_transaction_mod <- df_transaction_mod %>% 
  mutate(
    year = year(date),
    month = month(date)
  )

years_avg <- df_transaction_mod %>% 
  group_by(
    account_id,
    cashflow,
    year
  ) %>% 
  summarise(amount_mean = mean(amount)) %>% 
  pivot_wider(names_from = cashflow, values_from = amount_mean) %>% 
  mutate(balance_sheet = IN - OUT) 

balance_sheet <- years_avg %>% 
    select(
      account_id,
      year,
      balance_sheet
    ) %>% 
    arrange(year) %>% 
    pivot_wider(names_from = year, values_from = balance_sheet) %>% 
    arrange(account_id)
  
if (!grepl("balance_sheet_end_of.", names(balance_sheet)[2])) {
names(balance_sheet) <- paste0("balance_sheet_end_of.", names(balance_sheet))
}

```

Neu erstellte Spalte mit den Bilanzen an das bestehende df_mod anfügen.
```{r}
df_mod <- left_join(df_mod, balance_sheet, by = c("account.id" = "balance_sheet_end_of.account_id"))

```

Die durchschnittlichen Einkommen und Ausgaben pro Account und Jahr
```{r}
incomes_avg_per_year <- years_avg %>% 
  select(
    account_id,
    IN,
    year
  ) %>% 
  pivot_wider(names_from = year, values_from = IN)

if (!grepl("incomes_avg_per.", names(incomes_avg_per_year)[2])) {
names(incomes_avg_per_year) <- paste0("incomes_avg_per.", names(incomes_avg_per_year))
}

outgoes_avg_per_year <- years_avg %>% 
  select(
    account_id,
    OUT,
    year
  ) %>% 
  pivot_wider(names_from = year, values_from = OUT)

if (!grepl("outgoes_avg_per.", names(outgoes_avg_per_year)[2])) {
names(outgoes_avg_per_year) <- paste0("outgoes_avg_per.", names(outgoes_avg_per_year))
}

```

Anfügen der beiden neuen Spalten für die arithmetischen Mittel der Einkünfte und Geldrückzüge.
```{r}
df_mod <- left_join(df_mod, incomes_avg_per_year, by = c("account.id" = "incomes_avg_per.account_id"))

df_mod <- left_join(df_mod, outgoes_avg_per_year, by = c("account.id" = "outgoes_avg_per.account_id"))

rm(balance_sheet, incomes_avg_per_year, outgoes_avg_per_year, list_na_characterization_for_cashwidthrawal, df_transaction, years_avg)

```

Nun werden die Totalbeträge pro Jahr und und in einem weiteren Schritt pro Monat erstellt.

```{r}
years_total <- df_transaction_mod %>% 
  group_by(
    account_id,
    cashflow,
    year
  ) %>% 
  summarise(amount_total = sum(amount)) %>% 
  pivot_wider(names_from = cashflow, values_from = amount_total) %>% 
  mutate(balance_sheet = IN - OUT) 

balance_sheet_total <- years_total %>% 
    select(
      account_id,
      year,
      balance_sheet
    ) %>% 
    arrange(year) %>% 
    pivot_wider(names_from = year, values_from = balance_sheet) %>% 
    arrange(account_id)
  
if (!grepl("balance_sheet_total.", names(balance_sheet_total)[2])) {
names(balance_sheet_total) <- paste0("balance_sheet_total.", names(balance_sheet_total))
}

```

Neu erstellte Spalte mit den Bilanzen an das bestehende df_mod anfügen.
```{r}
df_mod <- left_join(df_mod, balance_sheet_total, by = c("account.id" = "balance_sheet_total.account_id"))

```

Die durchschnittlichen Einkommen und Ausgaben pro Account und Jahr
```{r}
incomes_total_per_year <- years_total %>% 
  select(
    account_id,
    IN,
    year
  ) %>% 
  pivot_wider(names_from = year, values_from = IN)

if (!grepl("incomes_total_per.", names(incomes_total_per_year)[2])) {
names(incomes_total_per_year) <- paste0("incomes_total_per.", names(incomes_total_per_year))
}

outgoes_total_per_year <- years_total %>% 
  select(
    account_id,
    OUT,
    year
  ) %>% 
  pivot_wider(names_from = year, values_from = OUT)

if (!grepl("outgoes_total_per.", names(outgoes_total_per_year)[2])) {
names(outgoes_total_per_year) <- paste0("outgoes_total_per.", names(outgoes_total_per_year))
}

```

Anfügen der beiden neuen Spalten für die arithmetischen Mittel der Einkünfte und Geldrückzüge.
```{r}
df_mod <- left_join(df_mod, incomes_total_per_year, by = c("account.id" = "incomes_total_per.account_id"))

df_mod <- left_join(df_mod, outgoes_total_per_year, by = c("account.id" = "outgoes_total_per.account_id"))
```

Nun werden noch die Summen pro Monat erstellt.
```{r}
month_total <- df_transaction_mod %>% 
  group_by(
    account_id,
    cashflow,
    year,
    month
  ) %>% 
  summarise(amount_total = sum(amount)) 
# %>% 
#   pivot_wider(names_from = cashflow, values_from = amount_total)
```


Transaktionen werden vorerst nicht weiter behandelt. Falls während den folgenden Analysen zusätzliche Informationen aus der Tabelle "transactions" benötigt wird, können diese Daten zu einem späteren Zeitpunkt hinzugefügt werden.

### **Erstellen des konsolidierten Data Frames**

Das konsolidierte Data Frame wird und dem Namen **df_cons** gespeichert.
Folgende Spalten aus dem Data Frame "df_mod" werden nicht mehr benötigt:
- 

```{r}

# df_cons <- df_mod %>% 
#   select(-c(
#     owner.client_id,
#     owner.disp_id,
#     user.client_id,
#     user.disp_id,
#     user.district_id,
#     loan.id,
#     card.id
#       ))


# rm(df_mod)
```

Übersicht über die Struktur des konsolidierten Datensatzes.

```{r}
glimpse(df_cons)
```

## 1. Datengrundlage

Die uns zu Grunde liegenden Daten lassen sich als von der Bank sowie als
exogen erhoben unterscheiden.

### a. Wie können die Daten noch weiter gruppiert und angeordnet werden, um eine optimale Grundlage für die Analyse zu bilden? (Luca)

```{r}

```

### b. Wie umfassend sind die Stichproben der Daten der Bank? Und trifft dies für alle einzelnen Datensätze zu? (Luca)

```{r}

```

### Zudem wird die Distribution der Datensätze und deren Qualität überprüft. (Luca)

```{r}

```

### c. Die Datenattribute werden alle auf ihre Verteilung sowie ihre Veränderung über die Zeit analysiert. Dabei werden technische Mittel der explorativen Datenanalyse angewendet. (Luca)

```{r}

```

#### i. Jegliche Datenattribute werden innerhalb des eigenen Datenrahmens analysiert. (Luca)

```{r}

```

## 2. Korrelationsanalysen

Nachdem die Datenattribute einzeln analysiert und geprüft wurden, sollen
sie miteinander mittels Korrelationsanalysen betrachtet werden. Dabei
sollten anfällige Zusammenhänge entdeckt werden.\
Beispiele für Hypothesen, welche in der Analyse überprüft werden
könnten, wären:

### a. Für die einzelne Datenattribute:

#### i. In welchem Monat oder Tag wird am meisten Geld abgehoben? (LBZ)

Levels vom Attribut trans_operation ausgeben:

```{r}
levels(df_cons$trans_operation)
```

Es gibt zwei verschiedene Arten von Geldabbuchungen. Erstere ist die
Geldabbuchung beziehungsweise Überweisung und die zweite die Abbuchung
mittels Kreditkarte. Diese beiden Arten werden getrennt analysiert.

```{r}

levels(df_cons$trans_characterization)
```

```{r}
levels(df_cons$trans_operation)
```

```{r}
n_card <- df_cons %>% 
  filter(
    trans_cashflow == "OUT",
    trans_operation == "CREDIT CARD WITHDRAWAL"
  ) %>% 
  nrow()

paste("Es wurden", n_card, "Kreditkatenbezüge getätigt.", sep = " ")

rm(n_card, card_withdrawal)

```

Der höchste Betrag, welcher mit der Kreditkarte bezogen wurde:

```{r}
df_cons %>% 
  filter(
    trans_cashflow == "OUT",
    trans_operation == "CASH WIDTHDRAWAL"
  ) %>% 
  select(
    trans_amount,
    trans_date,
    account_id
  ) %>% 
  top_n(1, trans_amount)
```

Für die weiteren Analysen wird eine zusätzliche Spalte für die Quartale
eines Jahres benötigt. Dazu wird das Jahr in vier Quartale unterteilt.

```{r}
summary(df_cons$trans_month)
```

```{r}
df_cons <- df_cons %>% 
  mutate(
    trans_quarter_year = case_when(
      (month(trans_date) <= 3) ~ "1. QUARTER",
      (month(trans_date) >= 4 & month(trans_date) <= 6) ~ "2. QUARTER",
      (month(trans_date) >= 7 & month(trans_date) <= 9) ~ "3. QUARTER",
      (month(trans_date) > 9) ~ "4. QUARTER"
    ),
    across(
      where(is.character), 
      as.factor
       )
  ) %>% 
  relocate(trans_quarter_year, .after = trans_date)

summary(df_cons$trans_quarter_year)
```

```{r}
df_cons %>% 
  filter(
    # trans_cashflow == "OUT",
    trans_operation == "CREDIT CARD WITHDRAWAL"
    # year(trans_date) == 1995,
    # trans_quarter_year == "1. QUARTER"
    ) %>% 
  ggplot(aes(
    x = account_id,
    y = trans_amount
  )
  # , fill = district_name
  ) +
  geom_jitter(
    alpha = 1,
    width = 30,
    shape = 3,
    color = "white"
  ) +
  labs(
    title = "Credit Card Withdrawal", 
    subtitle = "Withdrawals in 1995, 1st Quarter",
    x = "Account ID",
    y = "Amount [CZK]"
  ) +
  theme_dark()
```

Die meisten Kreditkartenbezüge sind unter 4000 CZK. Die
Kreditkartenbezüge über 4000 CZK werden in den nächsten Analysen genauer
untersucht.

Welche Accounts weisen die höchsten Bezüge an welchen Daten auf?

```{r}
df_cons %>% 
  filter(
    trans_operation == "CREDIT CARD WITHDRAWAL"
  ) %>% 
  select(
    trans_amount,
    trans_date, 
    account_id
  ) %>% 
  arrange(
    desc(trans_amount)
  ) %>% 
  top_n(1, trans_amount)
```

7 mal wurde in den Jahren '97 und '98 von versichiedenen Konten 8000
bezogen. Auffallend ist, dass der Account mit der Nummer 3654 drei mal
erscheint. Es stellt sich die Frage, ob am selben Datum mehrmals mit der
Kreditkarte vom selben Konto Geld abgehoben wurde. Dies soll nun
überprüft werden.

```{r}
df_cons %>% 
  filter(
    trans_operation == "CREDIT CARD WITHDRAWAL"
  ) %>% 
  group_by(
    trans_date,
    account_id
  ) %>% 
  count() %>% 
  arrange(desc(n))
```

```{r}
df_cons %>% 
  filter(
    trans_date == "1998-01-25",
    account_id == 96
  )
```

Es fällt auf, dass bei einigen Kreditkartenbezügen ein
order_payment_type angegeben ist. Zudem wurden die Bezüge dem
Account-Owner und dem User zugeordnet. Da bei den zugrunde liegenden
Daten nur das Transaktionsdatum ohne die Transaktionszeit vorliegt,
können wir nicht abschliessend beurteilen, ob es sich hier um doppelte
Erfassung oder tatsächlich getätigte Bezüge handelt. Wir gehen davon
aus, dass es sich um Doppelerfassungen handelt. Um dies zu verifizieren
muss geschaut werden, ob der User mehr Bezüge aufweist als der Owner.

```{r}
df_cons %>% 
  filter(
    trans_cashflow == "OUT"
  ) %>% 
  ggplot(aes(
    x = trans_amount
    , fill = disp_type
  )) +
  geom_histogram(
    position = "dodge"
    # , bins = 100
  ) +
  labs(
    title = "Cash outgoes", 
    subtitle = "Comparison between Account Owner and User",
    x = "Amount [CZK]",
    y = "Number of Transactions",
    fill = "Disposition type"
  ) + 
  scale_y_log10() +
  theme_light() 
```

Diese Analyse bestätigt die Vermutung, dass es sich bei den Werten um
Doppelerfassungen handelt. Deshalb werden die User für die nächsten
Analysen ausgeschlossen.

```{r}
df_cons %>% 
  filter(
    trans_operation == "CREDIT CARD WITHDRAWAL",
    disp_type == "OWNER",
    # !is.na(card_type),
    order_payment_type == "UNKNOWN"
  ) %>% 
  group_by(
    trans_date,
    card_id
  ) %>% 
  # summarise(amount_max = max(trans_amount)) %>% 
  # arrange(desc(amount_max))
  summarise(amount_avg = mean(trans_amount)) %>% 
  arrange(desc(amount_avg)) %>% 
  head()
```

Kreditkartenbezüge über 4000 CZK.

```{r}
df_cons %>% 
  filter(
    trans_operation == "CREDIT CARD WITHDRAWAL",
    disp_type == "OWNER",
    trans_amount > 4000
  ) %>% 
  ggplot(
    aes(
      x = trans_date,
      y = trans_amount,
      color = order_payment_type,
      fill = order_payment_type
    )
  ) + 
  geom_point(
    show.legend = FALSE
  ) +
  facet_wrap(vars(order_payment_type)) +
             # scales = "free_x") +
  theme_light() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    axis.line = element_line(color = "white")
  ) +
  labs(
    title = "Credit Card withdrawals",
    subtitle = "all over 4'000 CZK",
    x = "Transaction Date",
    y = "Amount [CZK]"
  )
             
```

Vermutlich können viele Kreditkartenbezüge über 4000 CZK nicht am
Automaten getätigt, sondern müssen am Schalter unter Angabe für den
Verwendungszweck abgehoben werden.

Hypothese: Um die Feiertage (Weihnachten und Ostern) wird mehr Geld mit
der Kreditkarte bezogen. Dazu werden nur die Bezüge "UNKONWN" und "NA"
aus order_payment_type angeschaut.

```{r}
#Korrelation Kreditkartenbezüge Unknown oder NA und Monate

df_cons %>% 
  filter(
    order_payment_type == "UNKONWN" 
    | is.na(order_payment_type),
   trans_operation == "CREDIT CARD WITHDRAWAL",
   disp_type == "OWNER"
  ) %>% 
  group_by(
    year = year(trans_date),
    month = month(trans_date),
    account_id
  ) %>% 
  summarise(amount_avg = round(mean(trans_amount))) %>% 
  arrange(desc(amount_avg))

```

```{r}
#nach unikaten Transaction ID filtern
df_cons %>% 
  # distinct(trans_id) %>% 
  filter(
    order_payment_type == "UNKONWN" 
    | is.na(order_payment_type),
   trans_operation == "CREDIT CARD WITHDRAWAL",
   # disp_type == "OWNER"
   # trans_id == unique(trans_id)
  ) %>% 
  group_by(
    year = year(trans_date),
    month = month(trans_date),
    account_id
  ) %>% 
  mutate(amount_avg = round(mean(trans_amount))) %>%
  ggplot(aes(
    x = month,
    y = amount_avg,
    # fill = trans_date
    )) +
  geom_point() +
  # geom_boxplot() +
  facet_wrap(vars(year))


```

### Cluster Kreditkartenbezüge

```{r}
#Clustering mit Jahresumsatz, user und owner, Art der Verbuchung (wofür wurde das Geld gebraucht), District.
#Korrelation zwischen Kreditkartenbezügen über 4000 und den Geldeingängen

dist_credit_card <- df_cons %>% 
  select(
    trans_id,
    trans_amount,
    trans_date, 
    trans_operation,
    trans_cashflow
  ) %>% 
  drop_na() %>%
  distinct() %>%
  mutate_if(is.numeric, .funs = funs(scale)) %>%
  head() %>%
  dist()

glimpse(dist_credit_card)
  
hc_credit_card <- hclust(dist_credit_card, method = "complete")

dend_credit_card <- as.dendrogram(hc_credit_card) 


plot(dend_credit_card)
```

```{r}
set.seed(42)

df_cons %>% 
  select(
    trans_id,
    trans_amount,
    trans_date, 
    trans_operation,
    trans_cashflow
  ) %>% 
  drop_na() %>%
  distinct(trans_id) %>%
  scale -> credit_card_cluster



kmeans_credit_card_2 <- kmeans(credit_card_cluster, centers = 2, nstart = 10)
kmeans_credit_card_3 <- kmeans(credit_card_cluster, centers = 3, nstart = 10)
kmeans_credit_card_4 <- kmeans(credit_card_cluster, centers = 4, nstart = 10)
kmeans_credit_card_5 <- kmeans(credit_card_cluster, centers = 5, nstart = 10)
kmeans_credit_card_6 <- kmeans(credit_card_cluster, centers = 6, nstart = 10)  


streuung_innerhalb <- c(kmeans_credit_card_2$tot.withinss,
kmeans_credit_card_3$tot.withinss,
kmeans_credit_card_4$tot.withinss,
kmeans_credit_card_5$tot.withinss,
kmeans_credit_card_6$tot.withinss)

streuung_df <- data_frame(
streuung_innerhalb,
anzahl_cluster = 2:6
)

ggplot(streuung_df) +
aes(x = anzahl_cluster,
y = streuung_innerhalb) +
geom_col() +
geom_line()
```

#### ii. Zu welchem Zeitpunkt wird am meisten Geld überwiesen? (LBZ)

```{r}

```

#### iii. Welche Datenattribute beschreiben den Kundenstamm und wie können Kundengruppen definiert werden? (LBZ)

```{r}

```

#### iv. Wann hat die Bank neue Kunden gewonnen und wie sieht diese Verteilung über die Zeit aus? (Christian)

```{r}
#Muss noch angepasst werden. Inputdaten fehlerhaft. 

#Filter that every Account only occurs once
df_cons_temp <- df_cons %>%
  group_by(account_date ) %>%
  filter(row_number() == 1)

ggplot(data = df_cons_temp, aes(x = account_date)) +
  geom_histogram(binwidth = 15, fill = "#88B8AC") +
  labs(title = "Opening of Account", subtitle = "subtitle") +
  xlab("Year") +
  ylab("Count") +
  theme_light()


rm(df_cons_temp)
```

#### iv. Wie sieht die Altersverteilung dieser Kunden aus und was kann daraus hergeleitet werden? (Christian)

```{r}
#Change dateofbirth of clients with lubridate and calculate age
df_cons$current_age <- as.numeric(difftime(Sys.Date(), df_cons$dateofbirth, units = "weeks")) / 52.25
#Schaltjahr berücksichtigen und Alter nicht über 100

#Round Age to the next full Number
df_cons$current_age <- floor(df_cons$current_age)

#Relocate rows so new column "current_age" is next to dateofbirth
df_cons <- df_cons %>%
  relocate(current_age, .after = dateofbirth)


#Create Barplot with distrbution of age 
df_cons_temp <- df_cons %>%
  group_by(account_id) %>%
  filter(row_number() == 1)

  ggplot(data = df_cons_temp, aes(current_age)) +
  geom_bar(fill = "#88B8AC") +
  labs(title = "Distribution of Customer Age", subtitle = "Male and Female combined") +
  xlab("Age in Years") +
  ylab("Count") +
  theme_light()

rm(df_cons_temp)

```

#### v. Neue Fragestellung (Aaron)

```{r}

```

#### vi. Wie sieht die Verteilung von Kreditkartentypen auf die Population der Kreditkarten aus?

```{r}

df_cons_credit_card_by_type <- df_cons %>%
  filter(!is.na(card_id)) %>%
  group_by(card_id) %>%
  mutate(card_type = card_type) %>%
  mutate(count = sum(n())) %>%
  mutate(frequency = paste0(round(prop.table(count), digits = 3)* 100, "%")) %>%
  select(sex, count, frequency, card_type) %>% 
  distinct()

df_cons_credit_card_by_type

ggplot(df_cons_credit_card_by_type, aes(fill = card_type, x = sex, y = count)) +
  labs(title = "Distribution of Credit Card Type per Sex", subtitle = "The percentage displayed on the plot is the frequency of the type over the whole population.") +
  geom_bar(position="fill", stat="identity") +
  #geom_text(aes(label = frequency), position = position_stack(vjust = 0.5), size = 2) +
  xlab("Sex") +
  ylab("Count") +
  labs(fill = "Card Type", )
  
  
```

#### vii. Wie sieht die Verteilung der Typen von Dispositionen aus?

```{r}


df_cons_distribution_disposition_type <- df_cons %>%
  filter(!is.na(disp_id)) %>%
  group_by(disp_id) %>%
  mutate(disp_type = disp_type) %>%
  mutate(count = sum(n())) %>%
  mutate(frequency = paste0(round(prop.table(count), digits = 3)* 100, "%")) %>%
  select(sex, count, frequency, disp_type) %>% 
  distinct()

df_cons_distribution_disposition_type

ggplot(df_cons_distribution_disposition_type, aes(fill = disp_type, x = count, y = sex)) +
  labs(title = "Distribution of disposition types", subtitle = "") +
  geom_bar(position="fill", stat="identity") +
  #geom_text(aes(label = frequency), position = position_stack(vjust = 0.5), size = 2) +
  xlab("Sex") +
  ylab("Count") +
  labs(fill = "Disposition Type")
```

#### viii. Was ist der am beliebtesten Modus einer Transaktion? (Aaron)

```{r}
df_cons_transaction_type_per_quarter <- df_cons %>%
  filter(!is.na(trans_id)) %>%
  group_by(trans_id) %>%
  mutate(trans_characterization = trans_characterization) %>%
  mutate(trans_quarter_year = trans_quarter_year) %>%
  mutate(count = sum(n())) %>%
  mutate(frequency = paste0(round(prop.table(count), digits = 3)* 100, "%")) %>%
  select(trans_quarter_year, count, frequency, trans_characterization) %>% 
  distinct()

df_cons_transaction_type_per_quarter

ggplot(df_cons_transaction_type_per_quarter, aes(fill = trans_characterization, x = trans_quarter_year, y = count)) +
  labs(title = "Distribution of transaction types per quarters", subtitle = "") +
  geom_bar(position="fill", stat="identity") +
  #geom_text(aes(label = frequency), position = position_stack(vjust = 0.5), size = 2) +
  xlab("Quarter") +
  ylab("Count") +
  labs(fill = "Transaction Type")

```

#### ix. Aus welchen Gründen (Charakterisierung) werden Transaktion durchgeführt und wie sieht die Verteilung dieser aus? (Aaron)

```{r}

```

#### x. In welchen Distrikten gibt es den höchsten Lohn? (Aaron)

```{r}
# df_cons_transaction_type_per_quarter <- df_cons %>%
#   group_by(district_id) %>%
#   mutate(average_salary = average_salary) %>%
#   mutate(district = district_name)
# 
# df_cons_transaction_type_per_quarter
# 
# ggplot(df_cons_transaction_type_per_quarter, aes(x=average_salary, fill=district)) + 
#   geom_bar( ) +
#   xlab("District") +
#   ylab("Average Salary") +
#   labs(fill = "District Name")

```

#### xi. Können neue Sonderangebote/Pakete geschaffen werden für die am meist verdienenden Kunden? (Aaron)

```{r}

```

### b. Für Korrelationen zwischen Datenattributen:

#### i. Prognosen für die Bank erarbeiten, um festzustellen, ob Kunden ihre Kredite zurückzahlen können. Die Kreditwürdigkeit des Kunden kann mithilfe der Analyse festgestellt werden und bei bereits laufenden Krediten können Massnahmen getroffen werden.

```{r}

```

#### ii. Wie sieht das Verhältnis der Benutzung von verschiedenen Zahlungsmitteln aller getätigten Transaktionen aus? Wie sieht die Entwicklung auf die Zeit aus? Kann man Prognosen daraus herleiten? Müssen wir das Geschäftsmodell anpassen?

```{r, warning = FALSE}
#Make plot with count of different Payment methods ("trans_operation") over time
df_cons %>%
  ggplot(mapping = aes(x = trans_date, fill = trans_operation)) +
  geom_histogram(binwidth = 5) +
  facet_wrap(~ trans_operation, ncol = 2, scales = "free_y") +
  labs(title = "Overwiev distribution of Transaction methods used from 1993 to 1999 ", subtitle = "Y-axis set independently", fill = "Method of Transaction" ) +
  xlab("Years") +
  ylab("Count") +
   theme(legend.position = "none") +
  scale_x_date(date_labels="%y",date_breaks ="1 year", date_minor_breaks = "1 month") +
  theme(axis.text.x = element_text(size = 8, angle=90,vjust =0.2)) 

```

#### iii. Wie viele der Kunden verwenden eine Kreditkarte von den Bonusprogrammen? Welche Attribute weisen diese Kunden auf? Können Angebote für spezifische Kundengruppen erstellt werden?

```{r}

```

#### iv. Korrelationsanalyse zwischen den Bankdaten und den soziodemografischen Daten.

### 1. Gibt es Unterschiede bei den Cashflows der Distrikte? Wieso gibt es diese Unterschiede? Was unterscheidet diese Distrikte?

```{r}

```

### 2. Wie sieht die Distribution von Kunden in den Distrikten aus im Bezug zu den restlichen Einwohnern? Können durch diese Zahlen neue Werbe-Kampagnen gestartet werden, welche zu einem Zuwachs von Kunden führen?

```{r}

```

### 3. Wie sieht die Entwicklung des Einkommens im Bezug zu den Prüfvariablen der Arbeitslosenrate und den begangenen Straftaten.

```{r}

```

#### v. Kann man Unterschiede herleiten, um Geschäfts- und Privatkunden zu unterteilen?

```{r}

```

#### vi. Wie sieht die Entwicklung der Kredite in Bezug auf Typ und Dauer aus? Kann aus der Grafik ein Trend ausgelesen werden?

```{r}

```

### 3. Welches Potenzial haben jegliche Datenobjekte und mit Hilfe welcher Mittel kann das beste Produkt daraus generiert werden? (Aaron) und jeder der noch kann....

```{r}

```
